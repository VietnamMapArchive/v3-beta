<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Allmaps overlay on OpenLayers</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- OpenLayers CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.5.2/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v7.5.2/dist/ol.js"></script>
  <style>
    /* Map logo */
    .map-logo { position: absolute; top: 10px; left: 10px; z-index: 1100; width: 60px; height: auto; border-radius: 8px; background: rgba(255,255,255,0.75); padding: 4px 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); pointer-events: none; }
    /* Reposition OpenLayers controls: zoom at top-right, rotate (north-up) below it (closer together) */
    .ol-zoom { top: 10px; right: 10px; left: auto; display: flex; flex-direction: column; gap: var(--ctlGap); z-index: 1100; }
    .ol-rotate { top: calc(10px + (var(--ctlSz) * 2) + var(--ctlGap) + 8px); right: 10px; left: auto; z-index: 1100; }
    /* Zoom & north-up button sizes */
    .ol-zoom button, .ol-rotate button { width: var(--ctlSz); height: var(--ctlSz); font-size: 16px; border-radius: 8px; }
    .ol-rotate button .ol-compass { font-size: 12px; }
    html, body { height: 100%; margin: 0; }
    :root { --vh: 100vh; --tabH: calc(var(--vh) / 3); }
    @supports (height: 100dvh) { :root { --vh: 100dvh; } }
    :root { --ctlSz: 34px; --ctlGap: 4px; }
    #map { position: relative; width: 100%; height: 100%; }
    .panel {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      background: rgba(255,255,255,0.95); padding: 12px 14px; border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15); font-family: system-ui, Arial, sans-serif; min-width: 300px;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px; }
    label { font-size: 12px; color: #333; }
    select, input[type="text"], button {
      font-size: 14px; padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; outline: none;
    }
    /* Prevent mobile (iOS/Android) zoom on input focus by keeping form controls >=16px */
    @media (hover:none) and (pointer:coarse) {
      input[type="text"],
      input[type="search"],
      input[type="email"],
      input[type="tel"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
        font-size: 16px;
      }
    }
    button { cursor: pointer; background: #111827; color: #fff; border: none; }
    button:disabled { opacity: 0.5; cursor: default; }
    .small { font-size: 12px; color: #444; }
    .inline { display: flex; gap: 8px; align-items: center; }
    .w-100 { width: 100%; }
    .muted { color: #666; }
    .pill {
      display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 11px; background: #f3f4f6; color: #111827;
    }
    .error { color: #b91c1c; }
    .ok { color: #065f46; }
    .link { color: #2563eb; text-decoration: none; }
    .kvgrid { display: grid; grid-template-columns: max-content 1fr; gap: 6px 12px; align-items: start; }
    .kv-key { font-weight: 600; color: #334155; white-space: nowrap; }
    .kv-val { color: #111827; overflow-wrap: anywhere; }
    .badge { display:inline-block; padding:1px 6px; border-radius:999px; background:#eef2ff; color:#3730a3; font-size:11px; }
    .bottombar {
      position: absolute; left: 0; right: 0; bottom: 0; z-index: 1000;
      background: rgba(255,255,255,0.95); border-radius: 12px 12px 0 0; padding: 8px 10px calc(8px + env(safe-area-inset-bottom, 0px));
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
      /* stack: tabs (fixed) + active panel (scroll) + credits (fixed) */
      display: flex; flex-direction: column; gap: 10px; align-items: stretch;
      height: var(--barH, var(--tabH)); max-height: 90vh; min-height: var(--barMin, 150px); overflow: hidden; box-sizing: border-box;
      /* Force compositing/painting on mobile Safari to avoid transparent-on-load bug */
      background-color: rgba(255,255,255,0.97); /* explicit color layer */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      backface-visibility: hidden;
      will-change: transform;
      isolation: isolate; /* new stacking context above map */
      -webkit-overflow-scrolling: touch; /* smooth panel scroll on iOS */
    }
    /* collapse/expand bottom bar except credit */
    .bottombar.collapsed { height: auto; min-height: 0; padding-top: 4px; padding-bottom: calc(4px + env(safe-area-inset-bottom, 0px)); }
    .bottombar.collapsed .bar-resizer,
    .bottombar.collapsed .tabs,
    .bottombar.collapsed .section-sep,
    .bottombar.collapsed .tab-panel { display: none !important; }
    .creditbar { display:flex; align-items:center; gap:8px; }
    /* drag handle to resize bottom bar */
    .bar-resizer { flex: 0 0 auto; height: 16px; cursor: ns-resize; display: flex; align-items: center; justify-content: center; touch-action: none; }
    .bar-resizer .grip { width: 56px; height: 5px; border-radius: 999px; background: #d1d5db; }
    .bar-resizer:hover .grip { background: #9ca3af; }
    .bottombar .lbl { font-size: 12px; color: #333; margin-right: 6px; }
    .bottombar .spacer { flex: 1; }
    /* Bigger action buttons */
    .btn-lg { font-size: 15px; padding: 10px 16px; border-radius: 10px; }
    .btn-green { background:#10b981; }
    .btn-green:hover { background:#059669; }
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 2000; }
    .modal.show { display: flex; }
    .modal .content { background: #fff; max-width: 720px; width: min(720px, 92vw); max-height: 80vh; overflow: auto; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); padding: 16px 18px; }
    .modal .hd { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .modal .close { background: transparent; border: none; font-size: 20px; line-height: 1; cursor: pointer; padding: 6px; }

    /* split guides + spyglass */
    .divider-v { position: absolute; top: 0; bottom: 0; width: 0; border-left: 2px dashed rgba(0,0,0,0.45); pointer-events: none; z-index: 999; display: none; }
    .divider-h { position: absolute; left: 0; right: 0; height: 0; border-top: 2px dashed rgba(0,0,0,0.45); pointer-events: none; z-index: 999; display: none; }
    .lens { position: absolute; pointer-events: none; border: 2px solid rgba(0,0,0,0.5); border-radius: 9999px; box-shadow: 0 0 0 2px rgba(255,255,255,0.85) inset; z-index: 999; display: none; cursor: default; }
    .lens:active { cursor: default; }

    /* drag handles */
    .handle, .lens-handle {
      position: absolute; width: 16px; height: 16px; border-radius: 9999px;
      background: #fff; border: 2px solid rgba(0,0,0,0.55); box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      z-index: 1000; display: none; pointer-events: auto;
    }
    .handle-v { cursor: ew-resize; }
    .handle-h { cursor: ns-resize; }
    .lens-handle { cursor: nwse-resize; }

    .range { width: 100%; }
    /* tabs */
    .tabs { display:flex; gap:8px; margin-bottom:6px; }
    .tab-btn { appearance:none; border:1px solid #d1d5db; background:#f8fafc; color:#111827; padding:6px 10px; border-radius:8px; font-size:13px; cursor:pointer; }
    /* labeled separator under tabs */
    .section-sep { display:flex; align-items:center; gap:10px; margin:4px 0 8px; }
    .section-sep::before, .section-sep::after { content:""; flex:1; height:2px; background: linear-gradient(to right, transparent, #cbd5e1, transparent); }
    .section-sep span { font-size:12px; font-weight:600; color:#111827; background: rgba(255,255,255,0.95); border:1px solid #e5e7eb; border-radius:999px; padding:3px 10px; }

    /* Simplify the tab separator: no label, single line */
    .section-sep { display:block; height:1px; background:#cbd5e1; margin:6px 0 8px; }
    .section-sep::before, .section-sep::after { content:none; }
    .section-sep span { display:none; }
    .tab-btn.active { background:#111827; color:#fff; border-color:#111827; }

    /* Sticky actions for More tab */
    #panelMore .sticky-actions { position: sticky; top: 0; z-index: 5; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; padding:8px 0; background: rgba(255,255,255,0.95); border-bottom:1px solid #e5e7eb; backdrop-filter: blur(2px); }
    /* Pretty pill buttons */
    .btn-chip { appearance:none; display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:9999px; border:1px solid #d1d5db; background: linear-gradient(#ffffff, #f8fafc); color:#111827; text-decoration:none; font-size:13px; font-weight:600; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }
    .btn-chip:hover { background:#f3f4f6; border-color:#cbd5e1; }
    .btn-chip:active { transform: translateY(1px); }

    /* colored action buttons */
    .btn-blue  { background:#2563eb; color:#fff; }
    .btn-blue:hover  { background:#1d4ed8; }
    .btn-indigo{ background:#6366f1; color:#fff; }
    .btn-indigo:hover{ background:#4f46e5; }
    .btn-red   { background:#ef4444; color:#fff; }
    .btn-red:hover   { background:#dc2626; }
    /* Control panel 4-column grid */
    .control-grid { display:grid; grid-template-columns: max-content 1fr max-content 1fr; grid-auto-rows: min-content; gap: 12px 16px; align-items: end; }
    .control-grid .inline { min-width: 0; }
    .control-grid .lbl { align-self: end; margin-right: 0; }
    .control-grid .span3 { grid-column: 1 / span 3; }
    .control-grid .right { justify-self: end; align-self: end; }
    @media (max-width: 1100px) {
      .control-grid { grid-template-columns: 1fr 1fr; }
      .control-grid .span3 { grid-column: 1 / -1; }
      .control-grid .right { justify-self: start; }
    }
    @media (max-width: 760px) {
      :root { --tabH: calc(var(--vh) / 3.8); }
      /* Mobile: two columns => Label | Selector */
      .control-grid { grid-template-columns: max-content 1fr; }
      /* Keep controls compact; make overlay input the same visual width as basemap */
      .control-grid #basemap,
      .control-grid #allmapsId { width: min(70vw, 260px); }
      /* Bigger resizer target on mobile */
      .bar-resizer { height: 28px; }
      .bar-resizer .grip { width: 72px; height: 6px; }
      /* Mobile: split Research toolbar into two lines */
      .toolbar { flex-wrap: wrap; justify-content: center; }
      .toolbar .break { display:block; flex-basis:100%; height:0; }
    }
    .tab-panel { display:none; width:100%; gap:10px; align-items:stretch; flex-direction:column; flex:1 1 auto; min-height:0; overflow:auto; }
    .tab-panel.active { display:flex; }
    /* tool buttons (single active) */
    .tool-btn { appearance:none; border:1px solid #d1d5db; background:#f8fafc; color:#111827; padding:6px 10px; border-radius:8px; font-size:13px; cursor:pointer; }
    .tool-btn.active { background:#111827; color:#fff; border-color:#111827; }

    /* Toolbar: desktop = single line (centered); mobile = two lines */
    .toolbar { display:flex; gap:14px; align-items:center; justify-content:center; flex-wrap:nowrap; }
    .toolbar .break { display:none; }

    /* annotation table */
    .tbl { width: 100%; border-collapse: collapse; }
    .tbl th, .tbl td { border: 1px solid #e5e7eb; padding: 6px 8px; font-size: 12px; }
    .tbl th { background: #f8fafc; text-align: left; font-weight: 600; }
    .tbl input[type="text"] { width: 100%; padding: 4px 6px; font-size: 12px; border: 1px solid #d1d5db; border-radius: 6px; }
    /* annotation list scroll container */
    .anno-wrap { width: 100%; margin-top: 8px; flex:1 1 auto; min-height:0; overflow:auto; }
    /* keep table header visible while scrolling */
    .tbl thead th { position: sticky; top: 0; background: #f8fafc; z-index: 1; }

    /* search panel */
    .results-wrap { width: 100%; margin-top: 8px; flex:1 1 auto; min-height:0; overflow:auto; }
    .results { display: grid; gap: 6px; }
    .result-item { border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px 10px; cursor: pointer; background:#fff; }
    .result-item:hover { background: #f8fafc; }
    .result-title { font-size: 13px; color:#111827; font-weight:600; }
    .result-sub { font-size: 12px; color:#4b5563; }
    /* cleaner two-column layout for search results */
    .result-item { display: flex; gap: 12px; align-items: center; }
    .result-item .col-left { flex: 1; min-width: 0; }
    .result-item .col-right { flex: 0 0 auto; display: flex; align-items: center; gap: 8px; }
    .btnAddSearch { padding: 6px 10px; font-size: 12px; border-radius: 8px; }

    /* Results fill the panel; panel scrolls within --tabH */
    #searchResults { max-height: none; overflow: visible; }
    #searchResults .result-item { padding: 8px 0; border-bottom: 1px solid #e5e7eb; }
    /* credit footer inside bottombar */
    .creditbar { flex: 0 0 auto; border-top: 1px solid #e5e7eb; padding-top: 6px; }
    .bottombar.collapsed .creditbar { border-top: none; padding-top: 0; }
    /* right-click coordinate popup */
    .coordmenu {
      position: absolute; z-index: 2500; display: none;
      background: #fff; border: 1px solid #e5e7eb; border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.18); padding: 10px; min-width: 220px;
    }
    .coordmenu .hd { font-weight: 600; font-size: 13px; color:#111827; margin-bottom: 6px; }
    .coordmenu .val { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; color:#111827; background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:6px 8px; cursor: pointer; user-select: all; }
    .coordmenu .sub { font-size: 12px; color:#6b7280; margin-top: 6px; }
    .coordmenu .actions { display:flex; gap:8px; margin-top:8px; }
    .coordmenu button { padding: 6px 10px; font-size: 12px; border-radius: 8px; background:#111827; color:#fff; border:none; cursor:pointer; }
  </style>
</head>
<body>
  <div id="map">
    <img class="map-logo" src="https://raw.githubusercontent.com/lqtue/VMA/main/data/logo.png" alt="Logo" />
    <div id="dividerX" class="divider-v"></div>
    <div id="dividerY" class="divider-h"></div>

    <div id="lens" class="lens"></div>
    <div id="lensHandle" class="lens-handle" title="Resize lens"></div>

    <div id="dividerHandleX" class="handle handle-v" title="Drag split (X)"></div>
    <div id="dividerHandleY" class="handle handle-h" title="Drag split (Y)"></div>
  </div>

  <div id="coordMenu" class="coordmenu" role="dialog" aria-label="Coordinates">
    <div class="hd">Coordinates (lon, lat)</div>
    <div id="coordValue" class="val">—</div>
    <div class="sub">Right-click shows location; click the value to copy.</div>
    <div class="actions">
      <button id="coordCopy" type="button">Copy</button>
      <button id="coordClose" type="button">Close</button>
    </div>
  </div>

  <div class="bottombar">
    <div id="barResizer" class="bar-resizer" role="separator" aria-orientation="vertical" title="Drag to resize">
      <div class="grip"></div>
    </div>
    <div class="tabs">
      <button id="tabControl" class="tab-btn active">Control</button>
      <button id="tabResearch" class="tab-btn">Research</button>
      <button id="tabSearch" class="tab-btn">Search</button>
      <button id="tabMore" class="tab-btn">More</button>
      <span class="spacer"></span>
      <button id="barHideBtn" class="tab-btn" title="Hide settings">Hide</button>
    </div>
    <div id="panelDivider" class="section-sep"><span id="panelDividerLabel">Control</span></div>

    <div id="panelControl" class="tab-panel active">
      <div class="control-grid">
        <!-- Row 1: labels -->
        <div class="lbl">Basemap</div>
        <div class="inline">
          <select id="basemap">
            <option value="osm" selected>OpenStreetMap</option>
            <option value="g-streets">Google Streets (see note)</option>
            <option value="g-satellite">Google Satellite (see note)</option>
          </select>
        </div>
        <div class="lbl">View</div>
        <div class="inline">
          <select id="viewMode">
            <option value="overlay" selected>Overlay</option>
            <option value="side-x">Side-by-side X</option>
            <option value="side-y">Side-by-side Y</option>
            <option value="spy">Spyglass</option>
          </select>
        </div>

        <!-- Row 2: labels/controls -->
        <div class="lbl">Overlay</div>
        <div class="inline">
          <input class="w-100" type="text" id="allmapsId" placeholder="e.g., 9b1b2f08…" />
        </div>
        <div class="lbl">Opacity</div>
        <div class="inline">
          <input id="opacityRange" class="range" type="range" min="0" max="1" step="0.01" value="0.70" />
          <span id="opLabel" class="small muted">0.70</span>
        </div>
      </div>
      <div class="inline" style="gap:12px; align-items:center; justify-content:center;">
        <button id="loadBtn" class="btn-green btn-lg">Load</button>
        <button id="metaBtn" class="btn-lg" title="Show metadata" disabled>Metadata</button>
      </div>
      <div id="status" class="small muted" aria-live="polite"></div>
    </div>

    <div id="panelResearch" class="tab-panel">
      <div class="toolbar">
        <button id="btnPoint" type="button" class="tool-btn">Point</button>
        <button id="btnLine" type="button" class="tool-btn">Line</button>
        <button id="btnPoly" type="button" class="tool-btn">Object</button>
        <span class="break"></span>
        <button id="importCsvBtn" type="button" class="btn-green">Load</button>
        <input id="importCsvInput" type="file" accept=".csv,text/csv" style="display:none;" />
        <button id="exportCsv" type="button" disabled>Save</button>
        <button id="researchClear" class="btn-red">Clear</button>
      </div>

      <div class="small muted" style="margin-top:6px;">Tip: In <b>Line</b> and <b>Object</b> modes, press <b>Enter</b> or click on the last point to finish drawing.</div>

      <div class="anno-wrap">
        <table id="annoTable" class="tbl">
          <thead>
            <tr><th>#</th><th>Type</th><th>Label</th><th>Metric</th><th>Actions</th></tr>
          </thead>
          <tbody id="annoTbody"></tbody>
        </table>
      </div>
    </div>

    <div id="panelSearch" class="tab-panel">
      <div class="inline" style="gap:10px; align-items: center; width:100%;">
        <span class="lbl">Place</span>
        <input id="searchQuery" type="text" class="w-100" placeholder="e.g., Ho Chi Minh City, Notre-Dame Cathedral" />
        <button id="searchBtn" type="button" class="btn-green">Search</button>
        <button id="searchClear" type="button" class="btn-red">Clear</button>
      </div>
      <div class="small muted" style="margin-top:6px;">Search powered by Nominatim / OpenStreetMap. Click a result to zoom. Use the <b>Add</b> button on a result to add it to annotations (the search list clears after adding).</div>
      <div class="results-wrap">
        <div id="searchResults" class="results"></div>
      </div>
    </div>
    <div id="panelMore" class="tab-panel">
      <div class="sticky-actions">
        <!-- TODO: replace example.com URLs with your real destinations -->
        <a class="btn-chip" href="https://example.com/about" target="_blank" rel="noreferrer">About Us</a>
        <a class="btn-chip" href="https://example.com/blog" target="_blank" rel="noreferrer">Blog</a>
        <a class="btn-chip" href="https://example.com/contact" target="_blank" rel="noreferrer">Get in touch</a>
      </div>
      <div class="small" style="margin-top:10px;">
        <div style="font-weight:600; margin-bottom:6px;">Tips & Shortcuts</div>
        <ul style="margin:0; padding-left: 18px; display:grid; gap:6px;">
          <li><b>Rotate map:</b> hold <b>Ctrl</b> (Windows/Linux) or <b>⌘ Cmd</b> (macOS) and drag. On touchpads, use a two‑finger rotate gesture. Click the rotate control to reset north‑up.</li>
          <li><b>Zoom:</b> scroll the mouse wheel or double‑click to zoom in.</li>
          <li><b>View modes:</b> pick <i>Overlay / Side‑by‑side X / Side‑by‑side Y / Spyglass</i>. In side‑by‑side, drag the small circle handle to move the divider. In spyglass, drag the small knob on the right edge to resize.</li>
          <li><b>Annotations:</b> choose Point/Line/Object. Press <b>Enter</b> to finish a line/polygon, <b>Esc</b> to cancel the current sketch. Edit labels in the table; use <i>Zoom</i> or <i>Delete</i> in the Actions column. Use <i>Export CSV</i> / <i>Import CSV</i> to save/restore.</li>
          <li><b>Search:</b> type a place and click <i>Search</i>. Click a result to zoom. Use the <i>Add</i> button on a result to add it to annotations (the search list clears after adding).</li>
          <li><b>Coordinates:</b> right‑click anywhere on the map to show lon,lat. Click the value or the <i>Copy</i> button to copy to clipboard.</li>
          <li><b>Opacity:</b> use the slider to adjust the overlay transparency.</li>
        </ul>
      </div>
    </div>
    <div class="creditbar small muted">
      <span>© The Vietnam Map Archive Project · OpenStreetMap contributors · Tiles via Allmaps · Built with OpenLayers</span>
      <span class="spacer"></span>
      <button id="barShowBtn" class="tab-btn" title="Show settings" style="display:none;">Show</button>
    </div>
  </div>

  <div id="metaModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="metaTitle">
    <div class="content">
      <div class="hd">
        <h3 id="metaTitle" style="margin:0;">Map metadata</h3>
        <button id="closeMeta" class="close" aria-label="Close">×</button>
      </div>
      <div id="metaSummary" class="small">–</div>
      <div class="small" style="margin-top:10px;">Footprint source: <span id="metaLinkWrap" class="muted">–</span></div>
      <div class="small muted" style="margin-top:10px;">Attribution: © <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank" rel="noreferrer">OpenStreetMap</a> contributors · Allmaps. Google tiles usage may require permission and a proper API.</div>
    </div>
  </div>

  <script>
    // --- Base layers ---
    const osmLayer = new ol.layer.Tile({
      source: new ol.source.OSM(),
      visible: true,
      properties: { 'name': 'osm', 'base': true },
      zIndex: 0
    });

    // Google via XYZ (⚠️ check TOS; replace only if you have permission)
    const googleStreets = new ol.layer.Tile({
      source: new ol.source.XYZ({
        urls: [
          'https://mt0.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
          'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
          'https://mt2.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
          'https://mt3.google.com/vt/lyrs=m&x={x}&y={y}&z={z}'
        ],
        maxZoom: 22,
        crossOrigin: 'anonymous',
        attributions: '© Google'
      }),
      visible: false,
      properties: { 'name': 'g-streets', 'base': true },
      zIndex: 0
    });

    const googleSatellite = new ol.layer.Tile({
      source: new ol.source.XYZ({
        urls: [
          'https://mt0.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          'https://mt2.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          'https://mt3.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'
        ],
        maxZoom: 22,
        crossOrigin: 'anonymous',
        attributions: '© Google'
      }),
      visible: false,
      properties: { 'name': 'g-satellite', 'base': true },
      zIndex: 0
    });

    // Historical overlay (initially empty)
    const overlayLayer = new ol.layer.Tile({
      source: new ol.source.XYZ({ url: '' }), // set when ID is loaded
      opacity: 0.70,
      visible: true,
      zIndex: 10,
      properties: { 'name': 'allmaps-overlay' }
    });

    // Optional: footprint outline layer (vector)
    const footprintSource = new ol.source.Vector();
    const footprintLayer = new ol.layer.Vector({
      source: footprintSource,
      style: new ol.style.Style({
        stroke: new ol.style.Stroke({ color: '#ef4444', width: 2 }),
        fill: new ol.style.Fill({ color: 'rgba(239,68,68,0.08)' })
      }),
      visible: false,
      zIndex: 15,
      properties: { 'name': 'footprint' }
    });

    // Research annotations layer (points/lines/polygons) with labels
    const researchSource = new ol.source.Vector();
    const researchLayer = new ol.layer.VectorImage({
      source: researchSource,
      zIndex: 20,
      imageRatio: 2,
      style: (() => {
        const stroke = new ol.style.Stroke({ color: '#2563eb', width: 2 });
        const fill   = new ol.style.Fill({ color: 'rgba(37,99,235,0.15)' });
        const pointBase = new ol.style.Style({
          image: new ol.style.Circle({
            radius: 5,
            fill: new ol.style.Fill({ color: '#2563eb' }),
            stroke: new ol.style.Stroke({ color: '#ffffff', width: 2 })
          })
        });
        const lineBase = new ol.style.Style({ stroke });
        const polyBase = new ol.style.Style({ stroke, fill });
        const cache = new Map(); // key = `${type}|${label}`

        function labelStyle(text, poly) {
          return new ol.style.Style({
            geometry: poly ? (f) => f.getGeometry().getInteriorPoint() : undefined,
            text: new ol.style.Text({
              text,
              font: '12px system-ui, Arial',
              fill: new ol.style.Fill({ color: '#111827' }),
              stroke: new ol.style.Stroke({ color: 'rgba(255,255,255,0.9)', width: 3 }),
              offsetY: poly ? 0 : -12,
              overflow: true
            })
          });
        }

        return (feature) => {
          const type  = feature.getGeometry().getType();
          const label = feature.get('label') || '';
          if (!label) {
            if (type === 'Point') return [pointBase];
            if (type.includes('Line')) return [lineBase];
            return [polyBase];
          }
          const key = `${type}|${label}`;
          let styles = cache.get(key);
          if (!styles) {
            if (type === 'Point') styles = [pointBase, labelStyle(label, false)];
            else if (type.includes('Line')) styles = [lineBase];
            else styles = [polyBase, labelStyle(label, true)];
            cache.set(key, styles);
          }
          return styles;
        };
      })(),
      properties: { 'name': 'research' }
    });

    // Search highlight layer
    const searchSource = new ol.source.Vector();
    const searchLayer = new ol.layer.VectorImage({
      source: searchSource,
      zIndex: 25,
      imageRatio: 2,
      style: new ol.style.Style({
        image: new ol.style.Circle({ radius: 6, fill: new ol.style.Fill({ color: '#f59e0b' }), stroke: new ol.style.Stroke({ color: '#fff', width: 2 }) }),
        stroke: new ol.style.Stroke({ color: '#f59e0b', width: 2, lineDash: [6,4] }),
        fill: new ol.style.Fill({ color: 'rgba(245,158,11,0.12)' })
      }),
      properties: { 'name': 'search' }
    });

    // Map
    const map = new ol.Map({
      target: 'map',
      layers: [osmLayer, googleStreets, googleSatellite, overlayLayer, footprintLayer, researchLayer, searchLayer],
      view: new ol.View({
        center: ol.proj.fromLonLat([106.70098, 10.77653]), // default center (HCMC)
        zoom: 12,
        enableRotation: true,
        constrainRotation: false
      })
    });

    // Add ScaleLine control explicitly (Attribution is included by default)
    map.addControl(new ol.control.ScaleLine());
    // Add a visible rotate control and rotation interactions
    map.addControl(new ol.control.Rotate({ autoHide: false }));
    map.addInteraction(new ol.interaction.DragRotate({
      condition: ol.events.condition.platformModifierKeyOnly
    }));
    map.addInteraction(new ol.interaction.PinchRotate());

    // UI elements
    const basemapSel = document.getElementById('basemap');
    const idInput = document.getElementById('allmapsId');
    const loadBtn = document.getElementById('loadBtn');
    const statusEl = document.getElementById('status');
    const metaLinkWrap = document.getElementById('metaLinkWrap');
    const metaSummary = document.getElementById('metaSummary');
    const metaBtn = document.getElementById('metaBtn');
    const metaModal = document.getElementById('metaModal');
    const closeMeta = document.getElementById('closeMeta');

    // Tabs
    const tabControl = document.getElementById('tabControl');
    const tabResearch = document.getElementById('tabResearch');
    const tabSearch = document.getElementById('tabSearch');
    const tabMore = document.getElementById('tabMore');
    const panelControl = document.getElementById('panelControl');
    const panelResearch = document.getElementById('panelResearch');
    const panelSearch = document.getElementById('panelSearch');
    const panelMore = document.getElementById('panelMore');

    // Research UI (single tool + table)
    const btnPoint = document.getElementById('btnPoint');
    const btnLine  = document.getElementById('btnLine');
    const btnPoly  = document.getElementById('btnPoly');
    const researchClear = document.getElementById('researchClear');
    const annoTbody = document.getElementById('annoTbody');
    const exportCsvBtn = document.getElementById('exportCsv');
    const importCsvBtn = document.getElementById('importCsvBtn');
    const importCsvInput = document.getElementById('importCsvInput');

    // Divider label under tabs
    const dividerLabel = document.getElementById('panelDividerLabel');
    function setDivider(text){ if (dividerLabel) dividerLabel.textContent = text; }

    // Search UI
    const searchQuery = document.getElementById('searchQuery');
    const searchBtn = document.getElementById('searchBtn');
    const searchClear = document.getElementById('searchClear');
    const searchResults = document.getElementById('searchResults');

    const viewModeSel = document.getElementById('viewMode');
    const opacityRange = document.getElementById('opacityRange');
    const opLabel = document.getElementById('opLabel');

    const dividerXEl = document.getElementById('dividerX');
    const dividerYEl = document.getElementById('dividerY');
    const dividerHandleX = document.getElementById('dividerHandleX');
    const dividerHandleY = document.getElementById('dividerHandleY');

    const lensEl = document.getElementById('lens');
    const lensHandle = document.getElementById('lensHandle');

    // --- Bottom bar resizer ---
    (function(){
      const bar = document.querySelector('.bottombar');
      const grip = document.getElementById('barResizer');
      if (!bar || !grip) return;
      const MIN_H = 150; // px – ensure tabs + separator + credit always visible
      function clamp2(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function apply(h){ bar.style.height = h + 'px'; }

      // Restore saved height if available
      const saved = Number(localStorage.getItem('barH') || '');
      if (!Number.isNaN(saved) && saved > 0) {
        const vh = window.innerHeight || document.documentElement.clientHeight || saved;
        apply(clamp2(saved, MIN_H, Math.round(vh * 0.9)));
      }

      let draggingBar = false;
      grip.addEventListener('pointerdown', (e) => {
        draggingBar = true; grip.setPointerCapture(e.pointerId); e.preventDefault();
      });
      window.addEventListener('pointermove', (e) => {
        if (!draggingBar) return;
        const vh = window.innerHeight || document.documentElement.clientHeight;
        const newH = clamp2(vh - e.clientY, MIN_H, Math.round(vh * 0.9));
        apply(newH);
      });
      function stopBarDrag(){
        if (!draggingBar) return;
        draggingBar = false;
        const h = Math.round(bar.getBoundingClientRect().height);
        localStorage.setItem('barH', String(h));
      }
      window.addEventListener('pointerup', stopBarDrag);
      window.addEventListener('pointercancel', () => { draggingBar = false; });
      // Double-click to reset to default (uses CSS var --tabH)
      grip.addEventListener('dblclick', () => { bar.style.height = ''; localStorage.removeItem('barH'); });
    })();

    // --- Collapse / Expand bottom bar (keep credit visible) ---
    (function(){
      const bar = document.querySelector('.bottombar');
      const btnHide = document.getElementById('barHideBtn');
      const btnShow = document.getElementById('barShowBtn');
      if (!bar || !btnHide || !btnShow) return;

      function expandToSaved(){
        const saved = Number(localStorage.getItem('barH') || '');
        if (!Number.isNaN(saved) && saved > 0) {
          const vh = window.innerHeight || document.documentElement.clientHeight || saved;
          const clamped = Math.max(120, Math.min(saved, Math.round(vh * 0.9)));
          bar.style.height = clamped + 'px';
        } else {
          bar.style.height = '';
        }
      }

      function collapseBar(){
        try {
          const h = Math.round(bar.getBoundingClientRect().height);
          if (h > 0) localStorage.setItem('barH', String(h));
        } catch(_){ }
        bar.classList.add('collapsed');
        bar.style.height = '';
        localStorage.setItem('barCollapsed','1');
        btnShow.style.display = '';
      }

      function expandBar(){
        bar.classList.remove('collapsed');
        expandToSaved();
        localStorage.removeItem('barCollapsed');
        btnShow.style.display = 'none';
      }

      if (btnHide) btnHide.addEventListener('click', collapseBar);
      if (btnShow) btnShow.addEventListener('click', expandBar);

      // Always start expanded on open (ignore previously saved collapsed state)
      localStorage.removeItem('barCollapsed');
      bar.classList.remove('collapsed');
      btnShow.style.display = 'none';
      // restore saved height (or default CSS var)
      expandToSaved();
      // iOS Safari can restore layout after bfcache; re-apply on pageshow
      window.addEventListener('pageshow', () => {
        bar.classList.remove('collapsed');
        btnShow.style.display = 'none';
        expandToSaved();
      });
    })();

    // Basemap switching
    function setBasemap(name) {
      [osmLayer, googleStreets, googleSatellite].forEach(l => l.setVisible(false));
      if (name === 'osm') osmLayer.setVisible(true);
      else if (name === 'g-streets') googleStreets.setVisible(true);
      else if (name === 'g-satellite') googleSatellite.setVisible(true);
    }
    basemapSel.addEventListener('change', () => setBasemap(basemapSel.value));

    // Modal open/close handlers
    function openMeta() { if (metaBtn.disabled) return; metaModal.classList.add('show'); }
    function closeMetaFn() { metaModal.classList.remove('show'); }
    if (metaBtn) metaBtn.addEventListener('click', openMeta);
    if (closeMeta) closeMeta.addEventListener('click', closeMetaFn);
    if (metaModal) metaModal.addEventListener('click', (e) => { if (e.target === metaModal) closeMetaFn(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeMetaFn(); });

    // Tabs behavior
    function showControlTab(){
      tabControl.classList.add('active');
      tabResearch.classList.remove('active');
      tabSearch.classList.remove('active');
      if (tabMore) tabMore.classList.remove('active');

      panelControl.classList.add('active');
      panelResearch.classList.remove('active');
      panelSearch.classList.remove('active');
      if (panelMore) panelMore.classList.remove('active');

      if (typeof setActiveTool === 'function') setActiveTool('none');
      setDivider('Control');
    }
    function showResearchTab(){
      tabResearch.classList.add('active');
      tabControl.classList.remove('active');
      tabSearch.classList.remove('active');
      if (tabMore) tabMore.classList.remove('active');

      panelResearch.classList.add('active');
      panelControl.classList.remove('active');
      panelSearch.classList.remove('active');
      if (panelMore) panelMore.classList.remove('active');
      setDivider('Research');
    }
    function showSearchTab(){
      tabSearch.classList.add('active');
      tabControl.classList.remove('active');
      tabResearch.classList.remove('active');
      if (tabMore) tabMore.classList.remove('active');

      panelSearch.classList.add('active');
      panelControl.classList.remove('active');
      panelResearch.classList.remove('active');
      if (panelMore) panelMore.classList.remove('active');

      if (typeof setActiveTool === 'function') setActiveTool('none');
      setDivider('Search');
    }
    function showMoreTab(){
      if (!tabMore || !panelMore) return;
      tabMore.classList.add('active');
      tabControl.classList.remove('active');
      tabResearch.classList.remove('active');
      tabSearch.classList.remove('active');

      panelMore.classList.add('active');
      panelControl.classList.remove('active');
      panelResearch.classList.remove('active');
      panelSearch.classList.remove('active');

      if (typeof setActiveTool === 'function') setActiveTool('none');
      setDivider('More');
    }
    if (tabControl) tabControl.addEventListener('click', showControlTab);
    if (tabResearch) tabResearch.addEventListener('click', showResearchTab);
    if (tabSearch) tabSearch.addEventListener('click', showSearchTab);
    if (tabMore) tabMore.addEventListener('click', showMoreTab);
    setDivider('Control');


    // --- View modes: overlay, side-x (vertical split), side-y (horizontal split), spyglass ---
    let currentMode = 'overlay';
    let sideRatio = 0.5;       // 0..1
    let lensRadius = 150;      // px
    let preKey = null, postKey = null;
    let dragging = { sideX:false, sideY:false, lensR:false };

    function unclip() {
      if (preKey) { ol.Observable.unByKey(preKey); preKey = null; }
      if (postKey) { ol.Observable.unByKey(postKey); postKey = null; }
      overlayLayer.changed();
    }

    function attachSideClip(orientation) {
      unclip();
      preKey = overlayLayer.on('prerender', function(e) {
        const ctx = e.context; if (!ctx) return;
        const pr = e.frameState.pixelRatio;
        const size = e.frameState.size; // CSS px
        const W = ctx.canvas.width, H = ctx.canvas.height;
        ctx.save(); ctx.beginPath();
        if (orientation === 'x') {
          const x = Math.max(0, Math.min(size[0]*sideRatio, size[0])) * pr;
          // overlay on RIGHT
          ctx.rect(x, 0, W - x, H);
        } else {
          const y = Math.max(0, Math.min(size[1]*sideRatio, size[1])) * pr;
          // overlay on BOTTOM
          ctx.rect(0, y, W, H - y);
        }
        ctx.clip();
      });
      postKey = overlayLayer.on('postrender', e => { const ctx=e.context; if (!ctx) return; ctx.restore(); });
      overlayLayer.changed();
    }

    function attachSpyClip() {
      unclip();
      preKey = overlayLayer.on('prerender', function(e) {
        const ctx = e.context; if (!ctx) return;
        const pr = e.frameState.pixelRatio;
        const size = e.frameState.size;
        const cx = (size[0]/2) * pr;
        const cy = (size[1]/2) * pr;
        const r  = Math.max(10, lensRadius) * pr;
        ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.clip();
      });
      postKey = overlayLayer.on('postrender', e => { const ctx=e.context; if (!ctx) return; ctx.restore(); });
      overlayLayer.changed();
    }

    function mapSize() { return map.getSize() || [0,0]; }
    function updateDividersAndHandles() {
      const [w,h] = mapSize();
      if (dividerXEl) { dividerXEl.style.display = (currentMode==='side-x')?'block':'none'; dividerXEl.style.left = (sideRatio*100)+'%'; }
      if (dividerYEl) { dividerYEl.style.display = (currentMode==='side-y')?'block':'none'; dividerYEl.style.top  = (sideRatio*100)+'%'; }

      // position divider handles
      if (dividerHandleX) {
        dividerHandleX.style.display = (currentMode==='side-x')?'block':'none';
        dividerHandleX.style.left = (sideRatio*w - 8) + 'px';
        dividerHandleX.style.top  = (h/2 - 8) + 'px';
      }
      if (dividerHandleY) {
        dividerHandleY.style.display = (currentMode==='side-y')?'block':'none';
        dividerHandleY.style.left = (w/2 - 8) + 'px';
        dividerHandleY.style.top  = (sideRatio*h - 8) + 'px';
      }
    }

    function updateLensAndHandle() {
      const [w,h] = mapSize();
      const cx = w/2;
      const cy = h/2;
      const d = Math.max(20, lensRadius*2);
      if (lensEl) {
        lensEl.style.display = (currentMode==='spy')?'block':'none';
        lensEl.style.width=d+'px'; lensEl.style.height=d+'px';
        lensEl.style.left=(cx - lensRadius)+'px'; lensEl.style.top=(cy - lensRadius)+'px';
      }
      if (lensHandle) {
        lensHandle.style.display = (currentMode==='spy')?'block':'none';
        lensHandle.style.left=(cx + lensRadius - 8)+'px';
        lensHandle.style.top =(cy - 8)+'px';
      }
    }

    function setMode(mode) {
      stopDrag();
      currentMode = mode;

      if (mode === 'overlay') {
        unclip();
        overlayLayer.setOpacity(parseFloat(opacityRange.value || '0.70'));
        if (lensEl) lensEl.style.display='none';
        if (lensHandle) lensHandle.style.display='none';
        if (dividerXEl) dividerXEl.style.display='none';
        if (dividerYEl) dividerYEl.style.display='none';
        if (dividerHandleX) dividerHandleX.style.display='none';
        if (dividerHandleY) dividerHandleY.style.display='none';
      }
      if (mode === 'side-x') {
        overlayLayer.setOpacity(parseFloat(opacityRange.value || '1'));
        if (lensEl) lensEl.style.display='none';
        if (lensHandle) lensHandle.style.display='none';
        attachSideClip('x'); updateDividersAndHandles();
      }
      if (mode === 'side-y') {
        overlayLayer.setOpacity(parseFloat(opacityRange.value || '1'));
        if (lensEl) lensEl.style.display='none';
        if (lensHandle) lensHandle.style.display='none';
        attachSideClip('y'); updateDividersAndHandles();
      }
      if (mode === 'spy') {
        if (dividerXEl) dividerXEl.style.display='none';
        if (dividerYEl) dividerYEl.style.display='none';
        if (dividerHandleX) dividerHandleX.style.display='none';
        if (dividerHandleY) dividerHandleY.style.display='none';
        overlayLayer.setOpacity(parseFloat(opacityRange.value || '1'));
        attachSpyClip(); updateLensAndHandle();
      }
    }

    // mode selector
    if (viewModeSel) viewModeSel.addEventListener('change', () => setMode(viewModeSel.value));

    // opacity
    if (opacityRange) opacityRange.addEventListener('input', () => {
      const v = parseFloat(opacityRange.value); opLabel.textContent = v.toFixed(2); overlayLayer.setOpacity(v);
      overlayLayer.changed();
    });

    // --- Research tools: single active tool (point | line | polygon) + annotation table ---
    let draw = null;
    let keyDownFinish = null;
    let keyDownCancel = null;
    let fidCounter = 1;

    function formatLen(m){ return (m>1000)? (m/1000).toFixed(2)+' km' : m.toFixed(1)+' m'; }
    function formatArea(a){ return (a>=1e6)? (a/1e6).toFixed(2)+' km²' : a.toFixed(1)+' m²'; }

    function getOrAssignId(feat){ if (!feat.getId()){ feat.setId('a'+(fidCounter++)); } return feat.getId(); }

    function metricForFeature(feat){
      const g = feat.getGeometry(); const t = g.getType();
      try{
        if (t==='Point'){
          const lonlat = ol.proj.toLonLat(g.getCoordinates());
          return lonlat[0].toFixed(5)+', '+lonlat[1].toFixed(5);
        } else if (t==='LineString'){
          const len = ol.sphere.getLength(g, { projection: 'EPSG:3857' });
          return formatLen(len);
        } else if (t==='Polygon'){
          const area = ol.sphere.getArea(g, { projection: 'EPSG:3857' });
          return formatArea(area);
        }
      } catch(_){ }
      return '—';
    }

    // Cap annotation list to N rows (then scroll)
    function applyAnnoMaxRows(n = 5) {
      // Heights handled by CSS (--tabH). Ensure no inline cap remains.
      const wrap = document.querySelector('.anno-wrap');
      if (wrap) wrap.style.maxHeight = '';
    }

    function refreshAnnoTable(){
      if (!annoTbody) return;
      const feats = researchSource.getFeatures();
      if (exportCsvBtn) exportCsvBtn.disabled = (feats.length === 0);
      let html = '';
      for (const f of feats){
        const id = getOrAssignId(f);
        const t = f.getGeometry().getType();
        const label = f.get('label') || '';
        const metric = metricForFeature(f);
        html += `<tr data-id="${id}">`
              + `<td>${id}</td>`
              + `<td>${t.replace('LineString','Line')}</td>`
              + `<td><input type="text" class="anno-label" value="${label.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}" /></td>`
              + `<td>${metric}</td>`
              + `<td><button class="anno-zoom">Zoom</button> <button class="anno-del">Delete</button></td>`
              + `</tr>`;
      }
      annoTbody.innerHTML = html || '<tr><td colspan="5" class="muted">No annotations yet.</td></tr>';

      // wire inputs and buttons
      annoTbody.querySelectorAll('tr[data-id]').forEach(row => {
        const id = row.getAttribute('data-id');
        const f = researchSource.getFeatureById(id);
        if (!f) return;
        const input = row.querySelector('input.anno-label');
        if (input) input.addEventListener('input', () => { f.set('label', input.value); researchLayer.changed(); });
        const btnZ = row.querySelector('button.anno-zoom');
        if (btnZ) btnZ.addEventListener('click', () => {
          const ext = f.getGeometry().getExtent();
          map.getView().fit(ext, { padding:[80,20,20,20], duration: 300, maxZoom: 18 });
        });
        const btnD = row.querySelector('button.anno-del');
        if (btnD) btnD.addEventListener('click', () => { researchSource.removeFeature(f); });
      });
      applyAnnoMaxRows(5);
    }

    function cleanupTool(){
      if (draw) { map.removeInteraction(draw); draw = null; }
      if (keyDownFinish) { document.removeEventListener('keydown', keyDownFinish); keyDownFinish = null; }
      if (keyDownCancel) { document.removeEventListener('keydown', keyDownCancel); keyDownCancel = null; }
      [btnPoint, btnLine, btnPoly].forEach(b => b && b.classList.remove('active'));
    }

    function setActiveTool(mode){
      cleanupTool();
      if (!mode || mode==='none') return;

      let type = null;
      if (mode==='point') { type='Point'; if (btnPoint) btnPoint.classList.add('active'); }
      else if (mode==='line') { type='LineString'; if (btnLine) btnLine.classList.add('active'); }
      else if (mode==='polygon') { type='Polygon'; if (btnPoly) btnPoly.classList.add('active'); }
      if (!type) return;

      draw = new ol.interaction.Draw({ source: researchSource, type, stopClick:true });
      map.addInteraction(draw);

      // Enter finishes (line & polygon); Esc cancels current sketch (line & polygon)
      if (mode==='line' || mode==='polygon') {
        keyDownFinish = (e) => { if (e.key === 'Enter') { e.preventDefault(); try{ draw.finishDrawing(); }catch(_){} } };
        document.addEventListener('keydown', keyDownFinish);
      }
      if (mode==='line' || mode==='polygon') {
        keyDownCancel = (e) => { if (e.key === 'Escape') { e.preventDefault(); try{ draw.abortDrawing(); }catch(_){} } };
        document.addEventListener('keydown', keyDownCancel);
      }

      draw.on('drawend', (e) => { getOrAssignId(e.feature); refreshAnnoTable(); });
    }

    // Hook tool buttons (toggle off if clicking the active one)
    if (btnPoint) btnPoint.addEventListener('click', () => setActiveTool(btnPoint.classList.contains('active') ? 'none' : 'point'));
    if (btnLine)  btnLine .addEventListener('click', () => setActiveTool(btnLine .classList.contains('active') ? 'none' : 'line'));
    if (btnPoly)  btnPoly .addEventListener('click', () => setActiveTool(btnPoly .classList.contains('active') ? 'none' : 'polygon'));

    // table sync
    researchSource.on('addfeature', refreshAnnoTable);
    researchSource.on('removefeature', refreshAnnoTable);

    if (researchClear) researchClear.addEventListener('click', () => { researchSource.clear(); refreshAnnoTable(); });

    // initial state: no tool active
    setActiveTool('none');
    refreshAnnoTable();


    // --- Nominatim search ---
    function escHtml(s){ return String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

    function renderSearchItems(items){
      if (!searchResults) return;
      if (!items || !items.length){ searchResults.innerHTML = '<div class="small muted">No results.</div>'; return; }
      searchResults.innerHTML = '';
      items.forEach((it, idx) => {
        const div = document.createElement('div');
        div.className = 'result-item';
        const title = escHtml(it.display_name || `${it.type || ''}`);
        const sub = escHtml([it.class, it.type, it.category].filter(Boolean).join(' · '));
        div.innerHTML = `
            <div class="col-left">
              <div class="result-title">${title}</div>
              <div class="result-sub">${sub}</div>
            </div>
            <div class="col-right">
              <button type="button" class="btnAddSearch">Add</button>
            </div>
          `;
        // Left-click anywhere on the item still zooms
        div.addEventListener('click', () => zoomToSearchResult(it));
        // Add button: add to annotations (and clear search via addResultToAnnotations)
        const addBtn = div.querySelector('.btnAddSearch');
        if (addBtn) addBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          addResultToAnnotations(it);
        });
        searchResults.appendChild(div);
      });
    }

    function zoomToSearchResult(it){
      try {
        searchSource.clear();
        // geometry if provided
        if (it.geojson) {
          const gjFmt = new ol.format.GeoJSON();
          const feat = gjFmt.readFeature({ type:'Feature', geometry: it.geojson }, { dataProjection:'EPSG:4326', featureProjection:'EPSG:3857' });
          feat.set('label', it.display_name || it.name || it.type || '');
          searchSource.addFeature(feat);
          const ext = feat.getGeometry().getExtent();
          map.getView().fit(ext, { padding:[80,20,20,20], duration: 400, maxZoom: 18 });
        } else if (it.boundingbox) {
          // boundingbox: [lat_s, lat_n, lon_w, lon_e]
          const bb = it.boundingbox.map(Number);
          const extent = [bb[2], bb[0], bb[3], bb[1]]; // [minLon, minLat, maxLon, maxLat]
          const ext3857 = ol.proj.transformExtent(extent, 'EPSG:4326', 'EPSG:3857');
          const poly = ol.geom.Polygon.fromExtent(ext3857);
          const fpoly = new ol.Feature({ geometry: poly });
          fpoly.set('label', it.display_name || it.name || it.type || '');
          searchSource.addFeature(fpoly);
          map.getView().fit(ext3857, { padding:[80,20,20,20], duration: 400, maxZoom: 18 });
        } else if (it.lat && it.lon) {
          const c = ol.proj.fromLonLat([Number(it.lon), Number(it.lat)]);
          const f = new ol.Feature({ geometry: new ol.geom.Point(c) });
          f.set('label', it.display_name || it.name || it.type || '');
          searchSource.addFeature(f);
          map.getView().animate({ center: c, duration: 400, zoom: Math.max(map.getView().getZoom()||12, 15) });
        }
      } catch(e) { console.warn(e); }
    }

    function addResultToAnnotations(it){
      try {
        let feat = null;
        if (it.geojson) {
          const gjFmt = new ol.format.GeoJSON();
          feat = gjFmt.readFeature({ type:'Feature', geometry: it.geojson }, { dataProjection:'EPSG:4326', featureProjection:'EPSG:3857' });
        } else if (it.boundingbox) {
          const bb = it.boundingbox.map(Number);
          const extent = [bb[2], bb[0], bb[3], bb[1]]; // [minLon, minLat, maxLon, maxLat]
          const ext3857 = ol.proj.transformExtent(extent, 'EPSG:4326', 'EPSG:3857');
          const poly = ol.geom.Polygon.fromExtent(ext3857);
          feat = new ol.Feature({ geometry: poly });
        } else if (it.lat && it.lon) {
          const c = ol.proj.fromLonLat([Number(it.lon), Number(it.lat)]);
          feat = new ol.Feature({ geometry: new ol.geom.Point(c) });
        }
        if (!feat) return;
        const lbl = it.display_name || it.name || it.type || '';
        if (lbl) feat.set('label', lbl);
        researchSource.addFeature(feat);
        // Clear search layer and UI after adding
        searchSource.clear();
        if (searchResults) searchResults.innerHTML = '';
        if (searchQuery) searchQuery.value = '';
        refreshAnnoTable();
      } catch(e){ console.warn(e); }
    }

    let searchAbort = null;
    let searchTimer = null;

    async function runSearchNow(){
      const q = (searchQuery?.value || '').trim();
      if (!q){ if (searchResults) searchResults.innerHTML = '<div class="small muted">Enter a place or address.</div>'; return; }

      if (searchAbort) { try{ searchAbort.abort(); }catch(_){} }
      searchAbort = new AbortController();

      if (searchResults) searchResults.innerHTML = '<div class="small muted">Searching…</div>';
      try {
        const params = new URLSearchParams({
          format:'jsonv2', q,
          addressdetails:'1', namedetails:'1',
          polygon_geojson:'1', limit:'10'
        });
        const res = await fetch(`https://nominatim.openstreetmap.org/search?${params.toString()}`, {
          headers: { 'Accept':'application/json' },
          signal: searchAbort.signal
        });
        if (!res.ok) throw new Error('Search failed: '+res.status);
        const data = await res.json();
        renderSearchItems(Array.isArray(data) ? data : []);
      } catch(err) {
        if (err.name === 'AbortError') return;
        console.error(err);
        if (searchResults) searchResults.innerHTML = '<div class="small error">Search error. Please try again.</div>';
      }
    }

    function queueSearch(){
      if (searchTimer) clearTimeout(searchTimer);
      searchTimer = setTimeout(runSearchNow, 400);
    }

    if (searchBtn) searchBtn.addEventListener('click', runSearchNow);
    if (searchQuery) {
      searchQuery.addEventListener('input', queueSearch);
      searchQuery.addEventListener('keydown', (e)=>{ if (e.key==='Enter') runSearchNow(); });
    }
    if (searchClear) searchClear.addEventListener('click', () => {
      if (searchAbort) { try{ searchAbort.abort(); }catch(_){} }
      if (searchResults) searchResults.innerHTML='';
      searchSource.clear();
      if (searchQuery) searchQuery.value='';
    });


    // --- CSV export / import for annotations ---
    const wktFormat = new ol.format.WKT();

    function csvEscape(val){
      if (val == null) return '';
      const s = String(val);
      if (/[,"\n\r]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }

    function featureToCsvRow(f){
      const id = f.getId() || '';
      const geom = f.getGeometry();
      const type = geom.getType();
      const label = f.get('label') || '';
      const wkt = wktFormat.writeGeometry(geom); // EPSG:3857
      return [id, type, label, wkt].map(csvEscape).join(',');
    }

    function downloadCsv(){
      const header = 'id,type,label,wkt';
      const rows = researchSource.getFeatures().map(featureToCsvRow);
      const csv = [header].concat(rows).join('\r\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `annotations-${ts}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function parseCsvLine(line){
      const out = []; let cur = ''; let i=0; const n=line.length; let inQ=false;
      while(i<n){
        const ch=line[i++];
        if (inQ){
          if (ch==='"'){
            if (i<n && line[i]==='"'){ cur+='"'; i++; } else { inQ=false; }
          } else { cur+=ch; }
        } else {
          if (ch===','){ out.push(cur); cur=''; }
          else if (ch==='"'){ inQ=true; }
          else { cur+=ch; }
        }
      }
      out.push(cur);
      return out;
    }

    function importCsv(text){
      const lines = text.split(/\r?\n/).filter(l => l.trim().length>0);
      if (!lines.length) return 0;
      let start = 0;
      const head = parseCsvLine(lines[0]).map(h => h.trim().toLowerCase());
      if (head.join(',') === 'id,type,label,wkt') start = 1;
      let count = 0;
      for (let i=start;i<lines.length;i++){
        const cols = parseCsvLine(lines[i]);
        if (cols.length < 4) continue;
        const [idRaw, type, label, wkt] = cols;
        let geom;
        try { geom = wktFormat.readGeometry(wkt); } catch(_) { continue; }
        const feat = new ol.Feature({ geometry: geom });
        if (label) feat.set('label', label);
        let id = idRaw && idRaw.trim() ? idRaw.trim() : null;
        if (id && researchSource.getFeatureById(id)) {
          // make unique by suffixing a counter
          let k=1; let nid = id + '-' + k;
          while (researchSource.getFeatureById(nid)) { k++; nid = id + '-' + k; }
          id = nid;
        }
        if (id) feat.setId(id); else getOrAssignId(feat);
        researchSource.addFeature(feat);
        count++;
      }
      return count;
    }

    if (exportCsvBtn) exportCsvBtn.addEventListener('click', downloadCsv);
    if (importCsvBtn && importCsvInput) {
      importCsvBtn.addEventListener('click', () => importCsvInput.click());
      importCsvInput.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const text = String(reader.result || '');
          const added = importCsv(text);
          refreshAnnoTable();
          // reset input to allow re-uploading the same file name
          importCsvInput.value = '';
        };
        reader.readAsText(file);
      });
    }


    // --- Dragging (pointer events) ---
    const mapEl = document.getElementById('map');
    // --- Right-click coordinates popup ---
    const coordMenu  = document.getElementById('coordMenu');
    const coordValue = document.getElementById('coordValue');
    const coordCopy  = document.getElementById('coordCopy');
    const coordClose = document.getElementById('coordClose');

    function hideCoordMenu(){ if (coordMenu){ coordMenu.style.display='none'; } }

    function openCoordMenu(lon, lat, clientX, clientY){
      if (!coordMenu) return;
      const txt = `${lon.toFixed(6)}, ${lat.toFixed(6)}`;
      if (coordValue) coordValue.textContent = txt;

      // Show first to measure
      coordMenu.style.display = 'block';

      // clamp within viewport
      const pad = 8;
      const vw = window.innerWidth  || document.documentElement.clientWidth;
      const vh = window.innerHeight || document.documentElement.clientHeight;
      const rect = coordMenu.getBoundingClientRect();
      let left = clientX + 4;
      let top  = clientY + 4;
      if (left + rect.width + pad > vw) left = Math.max(pad, vw - rect.width - pad);
      if (top  + rect.height + pad > vh) top  = Math.max(pad, clientY - rect.height - 4);
      left = Math.max(pad, left);
      top  = Math.max(pad, top);

      coordMenu.style.left = left + 'px';
      coordMenu.style.top  = top  + 'px';
    }

    // Map right-click to show lon/lat
    if (map && typeof map.getViewport === 'function') {
      map.getViewport().addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const pixel = map.getEventPixel(e);
        const coord = map.getCoordinateFromPixel(pixel);
        if (!coord) return;
        const [lon, lat] = ol.proj.toLonLat(coord, 'EPSG:3857');
        openCoordMenu(lon, lat, e.clientX, e.clientY);
      });
    }

    // Copy helpers
    async function copyText(txt){
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(txt);
          return true;
        }
      } catch(_) {}
      // fallback
      const t = document.createElement('textarea');
      t.value = txt; t.style.position='fixed'; t.style.left='-9999px';
      document.body.appendChild(t); t.select();
      let ok = false;
      try { ok = document.execCommand('copy'); } catch(_){}
      document.body.removeChild(t);
      return ok;
    }

    if (coordCopy) coordCopy.addEventListener('click', async () => {
      const txt = coordValue ? coordValue.textContent : '';
      if (!txt || txt === '—') return;
      const ok = await copyText(txt);
      const old = coordCopy.textContent;
      coordCopy.textContent = ok ? 'Copied' : 'Copy failed';
      setTimeout(() => coordCopy.textContent = old, 900);
    });

    // Clicking the value also copies
    if (coordValue) coordValue.addEventListener('click', async (e) => {
      e.stopPropagation();
      const txt = coordValue.textContent || '';
      if (!txt || txt === '—') return;
      const ok = await copyText(txt);
      const old = coordValue.textContent;
      if (ok) {
        coordValue.textContent = 'Copied ✓';
        setTimeout(() => { coordValue.textContent = old; }, 900);
      }
    });

    if (coordClose) coordClose.addEventListener('click', hideCoordMenu);

    // Hide when clicking outside or pressing ESC
    document.addEventListener('pointerdown', (e) => {
      if (!coordMenu || coordMenu.style.display!=='block') return;
      if (e.target === coordMenu || coordMenu.contains(e.target)) return;
      hideCoordMenu();
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideCoordMenu(); });
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    let rafToken = 0;
    function schedule(fn){
      if (rafToken) return;
      rafToken = requestAnimationFrame(() => { rafToken = 0; fn(); });
    }
    function onMove(e) {
      if (!mapEl) return;
      const rect = mapEl.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const [w,h] = mapSize();

      if (dragging.lensR) {
        const cx = w/2, cy = h/2;
        const dx = x - cx, dy = y - cy;
        lensRadius = clamp(Math.sqrt(dx*dx + dy*dy), 20, Math.min(w,h)/2);
        updateLensAndHandle(); schedule(() => overlayLayer.changed()); return;
      }
      if (dragging.sideX) {
        sideRatio = clamp(x / w, 0.1, 0.9);
        updateDividersAndHandles(); schedule(() => overlayLayer.changed());; return;
      }
      if (dragging.sideY) {
        sideRatio = clamp(y / h, 0.1, 0.9);
        updateDividersAndHandles(); schedule(() => overlayLayer.changed());; return;
      }
    }
    function stopDrag(){ dragging = { sideX:false, sideY:false, lensR:false }; }

    if (dividerHandleX) dividerHandleX.addEventListener('pointerdown', (e)=>{ if (currentMode!=='side-x') return; dragging.sideX=true; dividerHandleX.setPointerCapture(e.pointerId); e.preventDefault(); });
    if (dividerHandleY) dividerHandleY.addEventListener('pointerdown', (e)=>{ if (currentMode!=='side-y') return; dragging.sideY=true; dividerHandleY.setPointerCapture(e.pointerId); e.preventDefault(); });
    if (lensHandle) lensHandle.addEventListener('pointerdown', (e)=>{ if (currentMode!=='spy') return; dragging.lensR=true; lensHandle.setPointerCapture(e.pointerId); e.preventDefault(); });

    window.addEventListener('pointermove', onMove, { passive: true });
    window.addEventListener('pointerup', stopDrag);
    window.addEventListener('pointercancel', stopDrag);

    // keep helpers aligned on map changes + resize
    map.getView().on('change:center', () => { if (currentMode==='spy') updateLensAndHandle(); if (currentMode==='side-x'||currentMode==='side-y') updateDividersAndHandles(); });
    map.getView().on('change:resolution', () => { if (currentMode==='spy') updateLensAndHandle(); if (currentMode==='side-x'||currentMode==='side-y') updateDividersAndHandles(); });
    window.addEventListener('resize', () => { updateLensAndHandle(); updateDividersAndHandles(); applyAnnoMaxRows(5); });

    // init
    setMode('overlay');


    // --- Friendly metadata summary (dynamic) ---
    const esc = (s) => String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    const fmtNum = (n) => (typeof n === 'number' ? n.toLocaleString() : n);
    const fmtArea = (a) => {
      if (typeof a !== 'number') return a;
      if (a >= 1_000_000) return `${(a/1_000_000).toLocaleString(undefined,{maximumFractionDigits:2})} km²`;
      return `${a.toLocaleString(undefined,{maximumFractionDigits:0})} m²`;
    };
    const fmtDate = (d) => {
      try { return new Date(d).toLocaleString(); } catch { return d; }
    };
    const short = (s, len=48) => {
      if (!s) return s;
      const str = String(s);
      return str.length > len ? esc(str.slice(0, len-1)) + '…' : esc(str);
    };

    function extractLabel(obj) {
      if (!obj) return undefined;
      // Common IIIF label patterns
      const lbl = obj?.label;
      if (typeof lbl === 'string') return lbl;
      if (lbl && typeof lbl === 'object') {
        if (Array.isArray(lbl.none) && lbl.none[0]) return lbl.none[0];
        if (Array.isArray(lbl.en) && lbl.en[0]) return lbl.en[0];
      }
      // Try nested partOf label
      const part = obj?.partOf;
      if (Array.isArray(part) && part[0]) return extractLabel(part[0]) || extractLabel(part[0]?.partOf?.[0]);
      return undefined;
    }

    function buildSummaryHTML(props, feature, extent4326) {
      if (!props) return '–';
      const rows = [];

      const title = extractLabel(props.resource) || extractLabel(props) || undefined;
      if (title) rows.push(['Title', title]);

      if (props.type) rows.push(['Type', props.type]);
      if (props.created) rows.push(['Created', fmtDate(props.created)]);
      if (props.modified) rows.push(['Modified', fmtDate(props.modified)]);

      const res = props.resource || {};
      if (res.id) rows.push(['Resource', `<a class="link" href="${esc(res.id)}" target="_blank" rel="noreferrer">${short(res.id)}</a>`]);
      if (typeof res.width === 'number' || typeof res.height === 'number') {
        rows.push(['Dimensions', `${fmtNum(res.width)} × ${fmtNum(res.height)} px`]);
      }
      // IIIF Canvas/Manifest
      const canvas = Array.isArray(res.partOf) && res.partOf[0] ? res.partOf[0] : undefined;
      if (canvas?.id) rows.push(['Canvas', `<a class="link" href="${esc(canvas.id)}" target="_blank" rel="noreferrer">${short(canvas.id)}</a>`]);
      const manifest = canvas?.partOf && Array.isArray(canvas.partOf) ? canvas.partOf[0] : undefined;
      if (manifest?.id) rows.push(['Manifest', `<a class="link" href="${esc(manifest.id)}" target="_blank" rel="noreferrer">${short(manifest.id)}</a>`]);

      // Transformation
      const tr = props.transformation;
      if (tr?.type) {
        const order = tr?.options?.order != null ? ` (order ${tr.options.order})` : '';
        rows.push(['Transformation', `${esc(tr.type)}${order}`]);
      }

      // Allmaps internal
      const am = props._allmaps || {};
      if (am.image?.id) rows.push(['Allmaps Image', `<a class="link" href="${esc(am.image.id)}" target="_blank" rel="noreferrer">${short(am.image.id)}</a>`]);
      if (typeof am.scale === 'number') rows.push(['Scale', fmtNum(am.scale)]);
      if (typeof am.area === 'number') rows.push(['Area', fmtArea(am.area)]);

      // GCPs
      const gcpCount = Array.isArray(props.gcps) ? props.gcps.length : undefined;
      if (gcpCount != null) rows.push(['GCPs', `${fmtNum(gcpCount)}`]);

      // Geometry extent (WGS84)
      if (extent4326) {
        const [minX,minY,maxX,maxY] = extent4326;
        const centerLon = (minX + maxX) / 2;
        const centerLat = (minY + maxY) / 2;
        rows.push(['Extent (lon/lat)', `${minX.toFixed(4)}, ${minY.toFixed(4)} → ${maxX.toFixed(4)}, ${maxY.toFixed(4)}`]);
        rows.push(['Center', `${centerLon.toFixed(5)}, ${centerLat.toFixed(5)}`]);
      }

      // Original map id
      if (props.id) rows.push(['Annotation ID', `<a class="link" href="${esc(props.id)}" target="_blank" rel="noreferrer">${short(props.id)}</a>`]);

      // Fallback: include any extra simple scalar props not already shown
      const shown = new Set(rows.map(r => r[0]));
      for (const [k,v] of Object.entries(props)) {
        if (shown.has(k)) continue;
        if (v == null) continue;
        if (['resource','gcps','resourceMask','transformation','_allmaps'].includes(k)) continue;
        if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {
          rows.push([k, esc(v)]);
        }
      }

      return `<div class="kvgrid">${rows.map(([k,v]) => `<div class="kv-key">${esc(k)}</div><div class="kv-val">${v}</div>`).join('')}</div>`;
    }

    function renderMetadataSummary(gj, feats, extent3857) {
      if (!metaSummary) return;
      try {
        const props = (gj && gj.features && gj.features[0] && gj.features[0].properties) ? gj.features[0].properties : null;
        const extent4326 = extent3857 ? ol.proj.transformExtent(extent3857, 'EPSG:3857','EPSG:4326') : null;
        const html = buildSummaryHTML(props, gj?.features?.[0], extent4326);
        metaSummary.innerHTML = html || '–';
      } catch (e) {
        console.error(e);
        metaSummary.textContent = 'Could not render summary.';
      }
    }


    // Helper: fit to features extent
    function fitToFeatures(features) {
      if (!features || features.length === 0) return;
      const extent = ol.extent.createEmpty();
      features.forEach(f => ol.extent.extend(extent, f.getGeometry().getExtent()));
      if (!ol.extent.isEmpty(extent)) {
        map.getView().fit(extent, { padding: [80, 20, 20, 20], duration: 500, maxZoom: 18 });
      }
    }

    // Load Allmaps overlay by ID
    async function loadAllmaps(id) {
      if (!id) return;
      if (statusEl) {
        statusEl.textContent = 'Loading tiles and footprint...';
        statusEl.className = 'small muted';
      }
      if (metaBtn) metaBtn.disabled = true;
      if (metaSummary) metaSummary.textContent = '–';

      // Update overlay tile source
      const tileUrl = `https://allmaps.xyz/images/${id}/{z}/{x}/{y}@2x.png`;
      overlayLayer.setSource(new ol.source.XYZ({
        url: tileUrl,
        crossOrigin: 'anonymous',
        maxZoom: 22,
        tilePixelRatio: (window.devicePixelRatio > 1 ? 2 : 1)
      }));
      overlayLayer.setVisible(true);

      // Fetch metadata (GeoJSON footprint)
      const metaUrl = `https://annotations.allmaps.org/images/${id}.geojson`;
      metaLinkWrap.innerHTML = `<a class="link" href="${metaUrl}" target="_blank" rel="noreferrer">${metaUrl}</a>`;

      try {
        const res = await fetch(metaUrl, { mode: 'cors' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const gj = await res.json();

        // Parse and draw footprint
        footprintSource.clear();
        const reader = new ol.format.GeoJSON();
        const feats = reader.readFeatures(gj, {
          dataProjection: 'EPSG:4326',
          featureProjection: 'EPSG:3857'
        });
        footprintSource.addFeatures(feats);

        let extent3857 = null;
        if (feats.length > 0) {
          extent3857 = ol.extent.createEmpty();
          feats.forEach(f => ol.extent.extend(extent3857, f.getGeometry().getExtent()));
        }
        if (feats.length > 0 && extent3857) {
          overlayLayer.setExtent(extent3857);
          fitToFeatures(feats);
        }


        renderMetadataSummary(gj, feats, extent3857);
        if (metaBtn) metaBtn.disabled = false;
        overlayLayer.changed();
        if (statusEl) statusEl.innerHTML = '';
      } catch (err) {
        console.error(err);
        if (statusEl) statusEl.innerHTML = '';
        // Clear footprint extent limit so tiles can still show if metadata failed
        overlayLayer.setExtent(undefined);
        if (metaSummary) metaSummary.textContent = '';
      }
    }

    // Wire button + Enter key
    loadBtn.addEventListener('click', () => loadAllmaps(idInput.value.trim()));
    idInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') loadAllmaps(idInput.value.trim());
    });

    // Support URL ?id=... to auto-load
    (function initFromQuery() {
      const u = new URL(location.href);
      const qid = u.searchParams.get('id');
      if (qid) {
        idInput.value = qid;
        loadAllmaps(qid);
      }
    })();
  </script>
</body>
</html>
