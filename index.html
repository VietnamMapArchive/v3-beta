<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VMA Map Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.5.2/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v7.5.2/dist/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@allmaps/openlayers/dist/bundled/allmaps-openlayers-8.umd.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom OpenLayers Control Positioning */
    .ol-zoom { top: 1rem !important; right: 1rem !important; left: auto !important; }
    .ol-rotate { top: calc(1rem + 50px) !important; right: 1rem !important; left: auto !important; }
    .ol-scale-line { background: rgba(255,255,255,0.7); padding: 2px 6px; border-radius: 6px; }

    /* Custom scrollbar for panels */
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }

    /* Sidebar collapse styles */
    #sidebar.collapsed {
      width: 64px; /* Tailwind w-16 */
    }
    #sidebar.collapsed .collapsible-content {
      display: none;
    }
    #sidebar.collapsed header .flex {
      justify-content: center;
    }
    #sidebar.collapsed #collapsed-nav {
      display: flex;
    }

    /* For Spyglass/Side-by-Side Dividers and Handles */
    .divider-v { position:absolute; top:0; left:0; width:0; height:0; border-left:2px dashed rgba(0,0,0,0.45); pointer-events:none; z-index:999; display:none; }
    .divider-h { position:absolute; top:0; left:0; width:0; height:0; border-top:2px dashed rgba(0,0,0,0.45); pointer-events:none; z-index:999; display:none; }
    .lens { position: absolute; pointer-events: none; border: 2px solid rgba(0,0,0,0.5); border-radius: 9999px; box-shadow: 0 0 0 2px rgba(255,255,255,0.85) inset; z-index: 999; display: none; cursor: default; }
    .handle, .lens-handle {
      position: absolute; width: 16px; height: 16px; border-radius: 9999px;
      background: #fff; border: 2px solid rgba(0,0,0,0.55); box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      z-index: 1000; display: none; pointer-events: auto;
    }
    .handle-v { cursor: ew-resize; }
    .handle-h { cursor: ns-resize; }
    .lens-handle { cursor: nwse-resize; }
    
    /* Active tab state styles */
    .tab-btn-desktop.active {
      background-color: #e5e7eb; /* gray-200 */
      color: #1f2937; /* gray-800 */
      border-bottom: 2px solid #4f46e5; /* indigo-600 */
    }
    
    .tool-btn.active {
      background-color: #1f2937; /* gray-800 */
      color: #ffffff;
      border-color: #1f2937;
    }
    .seg-btn.active {
      background-color: #1f2937; /* gray-800 */
      color: #ffffff;
      border-color: #1f2937;
    }
    .anno-label[readonly] {
      cursor: pointer;
    }
    .view-mode-btn.active {
      background-color: #eef2ff; /* indigo-100 */
      border-color: #4f46e5; /* indigo-600 */
      color: #4f46e5;
      font-weight: 600;
    }
    
    /* For Popup Arrow */
    #popup:before {
      content: "";
      position: absolute;
      top: 100%;
      left: 48px;
      border-width: 8px;
      border-style: solid;
      border-color: #d1d5db transparent transparent transparent;
    }

    /* Guided Tour styles */
    .tour-backdrop { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.55); z-index: 1100; display: none; }
    .tour-highlight { position: fixed; border-radius: 10px; box-shadow: 0 0 0 3px #6366f1, 0 10px 30px rgba(0,0,0,0.4); z-index: 1102; display: none; background: transparent; pointer-events: none; }
    .tour-popover {
      position: fixed; z-index: 1103; display: none; max-width: 340px;
      background: #fff; color: #111827; border: 1px solid #e5e7eb; border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    }
    .tour-popover .tour-header { padding: 10px 12px; border-bottom: 1px solid #e5e7eb; font-weight: 700; }
    .tour-popover .tour-body { padding: 10px 12px; font-size: 0.9rem; }
    .tour-popover .tour-footer { padding: 10px 12px; display: flex; align-items: center; justify-content: space-between; gap: 8px; border-top: 1px solid #e5e7eb; }
    .tour-popover .btn { padding: 6px 10px; font-weight: 600; border-radius: 8px; border: 1px solid #e5e7eb; }
    .tour-popover .btn-primary { background: #4f46e5; border-color: #4f46e5; color: #fff; }
    .tour-popover .btn-ghost { background: #fff; color: #374151; }
    .tour-popover .counter { font-size: 12px; color: #6b7280; }
  </style>
</head>
<body class="bg-gray-800 font-sans antialiased overflow-hidden">

  <div class="h-screen w-screen flex">
    <aside id="sidebar" class="relative z-20 h-full flex flex-col w-96 bg-gray-50 border-r border-gray-200 shadow-lg transition-all duration-300 ease-in-out">
      <header class="flex items-center justify-between gap-3 p-4 border-b border-gray-200 bg-white">
        <div class="flex items-center gap-3 overflow-hidden">
          <img src="https://raw.githubusercontent.com/lqtue/VMA/main/data/logo.png" alt="Logo" class="w-8 h-8 flex-shrink-0">
          <div class="collapsible-content">
            <h1 class="text-lg font-bold text-gray-800">Vietnam Map Archive project</h1>
            <p class="text-xs text-gray-500">Map Viewer</p>
          </div>
        </div>
        <div class="collapsible-content"></div>
      </header>

      <div id="collapsed-nav" class="hidden h-full flex-col items-center pt-5 space-y-4 bg-white border-r">
        <button data-tab="Map" class="collapsed-tab-btn p-3 rounded-lg hover:bg-gray-200" title="Map">
          <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13v-6m0-6V4m6 16l-5.447-2.724A1 1 0 019 16.382V5.618a1 1 0 011.447-.894L15 7m0 13v-6m0-6V4"></path></svg>
        </button>
        <button data-tab="Annotations" class="collapsed-tab-btn p-3 rounded-lg hover:bg-gray-200" title="Annotations">
          <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
        </button>
        <button data-tab="Story" class="collapsed-tab-btn p-3 rounded-lg hover:bg-gray-200" title="Story">
          <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
        </button>
        <button data-tab="Info" class="collapsed-tab-btn p-3 rounded-lg hover:bg-gray-200" title="Info">
          <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 9a3 3 0 116 0c0 2-2 3-3 3h-1v1" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 17h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </button>
      </div>
      
      <nav class="flex border-b border-gray-200 bg-gray-100 collapsible-content">
        <button data-tab="Map" class="tab-btn-desktop active flex-1 p-3 text-sm font-semibold text-center text-gray-500 hover:bg-gray-200 transition-colors">Map</button>
        <button data-tab="Annotations" class="tab-btn-desktop flex-1 p-3 text-sm font-semibold text-center text-gray-500 hover:bg-gray-200 transition-colors">Annotation</button>
        <button data-tab="Story" class="tab-btn-desktop flex-1 p-3 text-sm font-semibold text-center text-gray-500 hover:bg-gray-200 transition-colors">Story</button>
        <button data-tab="Info" class="tab-btn-desktop flex-1 p-3 text-sm font-semibold text-center text-gray-500 hover:bg-gray-200 transition-colors">Info</button>
      </nav>

      <div class="flex-1 overflow-y-auto custom-scrollbar collapsible-content">
        <div id="panelMap" class="tab-panel p-4 space-y-5">
          <div class="space-y-2">
            <label for="basemap" class="text-sm font-medium text-gray-700">Basemap</label>
            <select id="basemap" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
              <option value="esri-imagery" selected>Esri World Imagery</option>
              <option value="g-streets">Google Streets</option>
              <option value="g-satellite">Google Satellite</option>
            </select>
          </div>
          <div id="historicalMapModule" class="space-y-4 p-4 bg-gray-100 rounded-lg border border-gray-200">
            <h3 class="text-base font-semibold text-gray-800">Historical Map</h3>
            <div class="space-y-2">
              <label for="mapTypeFilter" class="text-sm font-medium text-gray-700">Map Type</label>
              <select id="mapTypeFilter" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                <option value="all" selected>All Types</option>
              </select>
            </div>
            <div class="space-y-2">
              <label for="allmapsId" class="text-sm font-medium text-gray-700">Choose Map</label>
              <select id="allmapsId" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></select>
            </div>
            <div class="space-y-2">
              <div class="flex items-center gap-2">
                <label for="customMapId" class="text-sm font-medium text-gray-700">or Custom Map ID</label>
                <a href="https://docs.google.com/document/d/1y-lMkiTF9v2gUij7zMp0nHOR2EfnUh3YQFdFN11JWPM/edit?usp=sharing" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-indigo-600" title="Learn more about Allmaps IDs">
                  <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>
                </a>
              </div>
              <div class="flex gap-2">
                <input type="text" id="customMapId" placeholder="Enter Allmaps ID, and Enter" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                <button id="loadCustomBtn" class="px-4 py-2 text-white bg-indigo-600 rounded-md hover:bg-indigo-700 font-semibold">Load</button>
              </div>
            </div>
          </div>
          <div id="viewControls" class="space-y-4">
            <div class="space-y-2">
              <label class="text-sm font-medium text-gray-700">View Mode</label>
              <div id="viewModeButtons" class="grid grid-cols-4 gap-2">
                  <button data-mode="overlay" class="view-mode-btn active p-2 border border-gray-300 rounded-md flex flex-col items-center justify-center hover:bg-gray-100" title="Overlay">
                      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                      <span class="text-xs mt-1">Overlay</span>
                  </button>
                  <button data-mode="side-x" class="view-mode-btn p-2 border border-gray-300 rounded-md flex flex-col items-center justify-center hover:bg-gray-100" title="Side-by-side Vertical">
                      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16v12H4zM12 6v12"></path></svg>
                      <span class="text-xs mt-1">Side X</span>
                  </button>
                  <button data-mode="side-y" class="view-mode-btn p-2 border border-gray-300 rounded-md flex flex-col items-center justify-center hover:bg-gray-100" title="Side-by-side Horizontal">
                      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16v12H4zM4 12h16"></path></svg>
                      <span class="text-xs mt-1">Side Y</span>
                  </button>
                  <button data-mode="spy" class="view-mode-btn p-2 border border-gray-300 rounded-md flex flex-col items-center justify-center hover:bg-gray-100" title="Spyglass">
                      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                      <span class="text-xs mt-1">Spyglass</span>
                  </button>
              </div>
            </div>
            <div class="space-y-2">
              <label class="text-sm font-medium text-gray-700">Opacity</label>
              <div class="flex items-center gap-3">
                <input id="opacityRange" type="range" min="0" max="1" step="0.01" value="0.80" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="opLabel" class="text-sm font-mono text-gray-600 w-10 text-center">80%</span>
              </div>
            </div>
          </div>
          <div class="pt-4 border-t border-gray-200 flex gap-2">
            <button id="metaBtn" disabled class="flex-1 px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed font-semibold">
              Metadata
            </button>
            <button id="zoomToMapBtn" class="flex-1 px-4 py-2 text-white bg-indigo-600 rounded-md hover:bg-indigo-700 font-semibold disabled:opacity-50 disabled:cursor-not-allowed" title="Zoom to map extent" disabled>
              Zoom to Extent
            </button>
          </div>
          <div class="flex items-center justify-center gap-2 min-h-[20px]">
            <div id="loader" class="hidden h-5 w-5 animate-spin rounded-full border-2 border-solid border-indigo-600 border-r-transparent"></div>
            <div id="status" class="text-sm text-gray-500"></div>
          </div>
          <div class="pt-4 border-t border-gray-200">
            <button id="clearStateBtn" class="w-full px-4 py-2 text-sm font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">Clear Cache & Reload</button>
            <p class="text-xs text-gray-500 mt-2">This will remove all saved annotations, story scenes, and view settings from your browser.</p>
          </div>
        </div>
        
        <div id="panelAnnotations" class="tab-panel hidden p-4 space-y-4">
          <div id="searchModule" class="pb-4 border-b">
            <div class="flex gap-2 items-center">
              <input id="searchQuery" type="text" placeholder="Search for a place..." class="flex-grow p-2 border border-gray-300 rounded-md">
              <button id="searchClearBtn" title="Clear search" class="p-2 text-white bg-red-600 rounded-md hover:bg-red-700">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
              <button id="searchLocate" title="Find my location" class="p-2 text-white bg-green-600 rounded-md hover:bg-green-700">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
              </button>
            </div>
            <div id="searchResults" class="mt-2 h-48 overflow-auto custom-scrollbar space-y-1">
            </div>
          </div>
          
          <div>
            <div id="drawTools" class="space-y-3 p-2 bg-gray-100 rounded-lg">
              <div class="flex gap-2 items-center">
                <span class="text-sm font-medium text-gray-700 w-14 text-right pr-2">Draw:</span>
                <div id="toolModeGroup" class="flex flex-1 select-none">
                  <button id="toolPointBtn" data-mode="point" class="seg-btn flex-1 px-2 py-1 text-xs font-medium bg-white border border-gray-300 rounded-l-md hover:bg-gray-100">Point</button>
                  <button id="toolLineBtn" data-mode="line" class="seg-btn flex-1 px-2 py-1 text-xs font-medium bg-white border-t border-b border-gray-300 hover:bg-gray-100">Line</button>
                  <button id="toolPolyBtn" data-mode="poly" class="seg-btn flex-1 px-2 py-1 text-xs font-medium bg-white border-t border-b border-gray-300 hover:bg-gray-100">Object</button>
                  <button id="toolEditBtn" data-mode="edit" class="seg-btn flex-1 px-2 py-1 text-xs font-medium bg-white border border-gray-300 rounded-r-md hover:bg-gray-100" title="Edit geometry (drag points/edges; Ctrl/⌘+Click deletes vertex)">Edit</button>
                </div>
              </div>
              <div id="annotationActions" class="flex gap-2 items-center flex-wrap">
                <input id="importCsvInput" type="file" accept=".csv,text/csv,.geojson,application/geo+json,application/json" class="hidden" />
                <button id="importCsvBtn" title="Load Annotations" class="flex-1 px-3 py-1.5 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-100">Load</button>
                <button id="exportCsv" title="Export Annotations" class="flex-1 px-3 py-1.5 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700 disabled:opacity-50" disabled>Export</button>
                <button id="researchClear" title="Clear All Annotations" class="flex-1 px-3 py-1.5 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700">Clear All</button>
              </div>
            </div>
            <div class="mt-2 h-80 overflow-auto custom-scrollbar border border-gray-200 rounded-lg">
              <table id="annoTable" class="w-full text-sm text-left text-gray-600" style="table-layout: fixed;">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0 z-10">
                  <tr>
                    <th scope="col" class="px-4 py-2">Label</th>
                    <th scope="col" class="px-4 py-2">Actions</th>
                  </tr>
                </thead>
                <tbody id="annoTbody" class="bg-white"></tbody>
              </table>
            </div>
          </div>
        </div>

        <div id="panelStory" class="tab-panel hidden p-4 space-y-4">
          <div id="story-capture-form" class="p-4 space-y-3 bg-gray-100 rounded-lg border border-gray-200">
            <input type="text" id="sceneTitleInput" placeholder="Scene Title" class="w-full p-2 border border-gray-300 rounded-md">
            <textarea id="sceneDetailsInput" placeholder="Scene Details..." rows="2" class="w-full p-2 border border-gray-300 rounded-md"></textarea>
            <div>
              <label for="sceneDelayInput" class="block text-sm font-medium text-gray-700 mb-1">Autoplay (seconds)</label>
              <input type="number" id="sceneDelayInput" value="2" min="1" max="60" class="w-full p-2 border border-gray-300 rounded-md">
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">Visible Annotations</label>
              <div id="sceneAnnotationList" class="h-32 overflow-y-auto custom-scrollbar border border-gray-300 rounded-md bg-white p-2 space-y-1">
                <p class="text-xs text-gray-500 p-2">No annotations available.</p>
              </div>
            </div>
            <div class="flex gap-2">
              <button id="captureSceneBtn" class="flex-1 px-4 py-2 text-white bg-indigo-600 rounded-md hover:bg-indigo-700 font-semibold">Capture Scene</button>
              <button id="cancelEditBtn" class="hidden px-4 py-2 text-white bg-red-600 rounded-md hover:bg-red-700 font-semibold">Cancel</button>
            </div>
          </div>
          <div id="storyActions" class="flex flex-wrap gap-2 justify-center p-2 rounded-lg">
            <input id="loadStoryInput" type="file" accept=".json,application/json" class="hidden" />
            <button id="loadStoryBtn" class="px-3 py-1.5 text-sm font-semibold text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-100">Load</button>
            <button id="downloadStoryBtn" class="px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 disabled:opacity-50" disabled>Export</button>
            <button id="presentStoryBtn" class="px-3 py-1.5 text-sm font-semibold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 disabled:opacity-50" disabled>Present</button>
          </div>
           <div class="h-60 overflow-auto custom-scrollbar border border-gray-200 rounded-lg">
            <ul id="story-list" class="divide-y divide-gray-200">
              <li class="p-4 text-center text-gray-500" id="story-placeholder">No scenes captured yet.</li>
            </ul>
          </div>
        </div>

        <div id="panelInfo" class="tab-panel hidden p-4 space-y-4">
          <div class="grid grid-cols-1 gap-4">
            <div class="space-y-3 p-4 bg-white border border-gray-200 rounded-lg">
              <h3 class="text-sm font-semibold text-gray-800">Quick Start</h3>
              <button id="startTourBtn" class="w-full px-3 py-2 text-sm font-semibold text-white bg-indigo-600 rounded-md hover:bg-indigo-700">Take a Tour</button>
            </div>
            <div class="space-y-3 p-4 bg-white border border-gray-200 rounded-lg">
              <h3 class="text-sm font-semibold text-gray-800">Links</h3>
              <div class="flex flex-wrap gap-2">
                <a class="px-3 py-1.5 text-xs font-semibold text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-100" href="https://www.canva.com/design/DAGsdCxbAho/UqzPt9W5ceAJH7sPdhvYOg/view?utm_content=DAGsdCxbAho&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h9602289aa0" target="_blank" rel="noreferrer">About Us</a>
                <a class="px-3 py-1.5 text-xs font-semibold text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-100" href="https://forms.gle/xJexnw5sDWxSETNt5" target="_blank" rel="noreferrer">Feedback</a>
                <a class="px-3 py-1.5 text-xs font-semibold text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-100" href="mailto:vietnam.ma.project@gmail.com" target="_blank" rel="noreferrer">Email Us</a>
              </div>
            </div>
          </div>
          <div class="p-4 bg-white border border-gray-200 rounded-lg">
            <details>
              <summary class="cursor-pointer text-sm font-semibold text-gray-800 select-none">Tips & Shortcuts</summary>
              <ul class="mt-2 list-disc list-inside space-y-1 text-xs text-gray-600">
                <li><b>Navigation:</b> Drag to pan, scroll to zoom, Ctrl/⌘+drag to rotate.</li>
                <li><b>Sidebar:</b> Use the arrow to collapse/expand for more map space.</li>
                <li><b>View Modes:</b> Side‑X/Side‑Y/Spyglass; drag handles to adjust.</li>
                <li><b>Annotations:</b> Draw Point/Line/Object; press Enter to finish, Esc to cancel.</li>
                <li><b>Stories:</b> Capture scenes, reorder, present or export.</li>
                <li><b>Data:</b> Load CSV/GeoJSON; Export GeoJSON (annotations); Story as JSON.</li>
                <li><b>Coordinates:</b> Right‑click the map; click value to copy.</li>
              </ul>
            </details>
          </div>
          <div class="text-center text-xs text-gray-400">Built with OpenLayers, Allmaps & OSM</div>
        </div>
      </div>
    </aside>
    <button id="sidebar-toggle" class="absolute z-20 top-1/2 -translate-y-1/2 w-8 h-16 bg-white hover:bg-gray-100 border-y border-r border-gray-300 rounded-r-full shadow-md flex items-center justify-center transition-all duration-300 ease-in-out">
      <svg id="sidebar-toggle-icon" class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path></svg>
    </button>

    <main class="flex-1 relative bg-gray-300">
      <div id="map" class="h-full w-full"></div>
      <div id="dividerX" class="divider-v"></div>
      <div id="dividerY" class="divider-h"></div>
      <div id="lens" class="lens"></div>
      <div id="lensHandle" class="lens-handle" title="Resize lens"></div>
      <div id="dividerHandleX" class="handle handle-v" title="Drag split (X)"></div>
      <div id="dividerHandleY" class="handle handle-h" title="Drag split (Y)"></div>
    </main>
  </div>

  

  <div id="coordMenu" class="hidden absolute z-50 min-w-[220px] bg-white border border-gray-300 rounded-lg shadow-xl p-3" role="dialog" aria-label="Coordinates">
    <div class="font-semibold text-sm text-gray-800 mb-2">Coordinates</div>
    <div id="coordValue" class="font-mono text-xs text-gray-800 bg-gray-100 border border-gray-200 rounded-md p-2 cursor-pointer select-all">—</div>
    <div class="text-xs text-gray-500 mt-2">Click the value to copy.</div>
    <div class="flex gap-2 mt-2">
        <button id="coordCopy" class="flex-1 px-3 py-1 text-xs font-semibold text-white bg-gray-800 rounded-md hover:bg-gray-900">Copy</button>
        <button id="coordClose" class="flex-1 px-3 py-1 text-xs font-semibold text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300">Close</button>
    </div>
  </div>

  <div id="popup" class="ol-popup relative z-[1050] bg-white rounded-lg shadow-lg border border-gray-300 min-w-[280px] max-w-[320px] pointer-events-auto">
    <a href="#" id="popup-closer" class="ol-popup-closer absolute top-1 right-2 text-xl text-gray-500 hover:text-gray-800">&times;</a>
    <div id="popup-content" class="p-3"></div>
  </div>
  
  <div id="presentation-overlay" class="hidden fixed inset-0 bg-transparent z-40 flex-col text-white font-sans pointer-events-none">
    <div class="absolute bottom-5 left-5 right-5 max-w-2xl mx-auto flex flex-col gap-3">
      <div id="presentation-nav" class="flex flex-wrap gap-3 items-center self-end pointer-events-auto">
          <span id="presentation-counter" class="font-mono text-sm px-3 py-1.5 bg-gray-900/80 border border-white/10 rounded-md"></span>
          <button id="presentation-prev" class="px-4 py-1.5 text-sm font-semibold text-white bg-gray-900/80 border border-white/10 rounded-md hover:bg-white/10 disabled:opacity-50">&lt; Prev</button>
          <button id="presentation-next" class="px-4 py-1.5 text-sm font-semibold text-white bg-gray-900/80 border border-white/10 rounded-md hover:bg-white/10 disabled:opacity-50">Next &gt;</button>
          <button id="presentation-play-pause" class="p-1.5 text-white bg-gray-900/80 border border-white/10 rounded-md hover:bg-white/10 flex items-center justify-center" title="Play/Pause Autoplay">
            <svg id="play-icon" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"></path></svg>
            <svg id="pause-icon" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M5.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75A.75.75 0 007.25 3h-1.5zM12.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75a.75.75 0 00-.75-.75h-1.5z"></path></svg>
          </button>
          <button id="presentation-exit" class="px-3 py-1.5 text-sm font-semibold text-white bg-gray-900/80 border border-white/10 rounded-md hover:bg-white/10">Exit</button>
      </div>
      <div id="presentation-content" class="w-full bg-gray-900/80 backdrop-blur-sm border border-white/10 rounded-lg p-5 pointer-events-auto">
          <h2 id="presentation-title" class="text-xl font-bold mb-2"></h2>
          <p id="presentation-details" class="text-sm max-h-24 overflow-y-auto"></p>
      </div>
    </div>
  </div>

  <!-- Guided Tour Overlay Elements -->
  <div id="tour-backdrop" class="tour-backdrop"></div>
  <div id="tour-highlight" class="tour-highlight"></div>
  <div id="tour-popover" class="tour-popover">
    <div class="tour-header" id="tour-title">Welcome</div>
    <div class="tour-body" id="tour-text">Let’s take a quick tour.</div>
    <div class="tour-footer">
      <span class="counter" id="tour-counter"></span>
      <div class="flex gap-2">
        <button id="tour-skip" class="btn btn-ghost">Skip</button>
        <button id="tour-prev" class="btn btn-ghost">Back</button>
        <button id="tour-next" class="btn btn-primary">Next</button>
      </div>
    </div>
  </div>

  <div id="metaModal" class="hidden fixed inset-0 bg-gray-900/60 z-[1050] flex items-center justify-center" role="dialog" aria-modal="true" aria-labelledby="metaTitle">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-[90vw] max-h-[80vh] flex flex-col">
      <div class="flex items-center justify-between p-4 border-b">
        <h3 id="metaTitle" class="text-lg font-bold text-gray-800">Map Metadata</h3>
        <button id="closeMeta" class="text-2xl text-gray-500 hover:text-gray-800" aria-label="Close">×</button>
      </div>
      <div id="metaSummary" class="p-4 overflow-y-auto text-sm space-y-2">
        <div class="grid grid-cols-[max-content,1fr] gap-x-4 gap-y-2">
          </div>
      </div>
      <div class="p-4 border-t text-xs text-gray-600">Footprint source: <span id="metaLinkWrap" class="text-gray-400">–</span></div>
    </div>
  </div>

  <div id="annoModal" class="hidden fixed inset-0 bg-gray-900/60 z-[1050] flex items-center justify-center" role="dialog" aria-modal="true" aria-labelledby="annoTitle">
    <div class="bg-white rounded-lg shadow-xl max-w-lg w-[90vw] max-h-[80vh] flex flex-col">
      <div class="flex items-center justify-between p-4 border-b">
        <h3 id="annoTitle" class="text-lg font-bold text-gray-800">Edit Annotation</h3>
        <button id="closeAnnoModal" class="text-2xl text-gray-500 hover:text-gray-800" aria-label="Close">×</button>
      </div>
      <div class="p-4 space-y-4 overflow-y-auto custom-scrollbar">
        <div>
          <label for="annoLabelInput" class="block text-sm font-medium text-gray-700 mb-1">Label</label>
          <input type="text" id="annoLabelInput" class="w-full p-2 border border-gray-300 rounded-md" placeholder="A short name for the feature">
        </div>
        <div>
          <label for="annoDetailsInput" class="block text-sm font-medium text-gray-700 mb-1">Details</label>
          <textarea id="annoDetailsInput" rows="3" class="w-full p-2 border border-gray-300 rounded-md" placeholder="Add detailed notes here..."></textarea>
        </div>
        <div>
          <label for="annoColorInput" class="block text-sm font-medium text-gray-700 mb-1">Color</label>
          <input type="color" id="annoColorInput" class="w-full h-10 p-1 border border-gray-300 rounded-md" value="#2563eb">
        </div>
        <div class="pt-4 border-t space-y-2">
          <div>
            <label for="annoImg1Input" class="block text-sm font-medium text-gray-700 mb-1">Image URL</label>
            <input type="text" id="annoImg1Input" class="w-full p-2 border border-gray-300 rounded-md" placeholder="https://...">
          </div>
          <div id="annoImg2Container" class="hidden space-y-1">
            <label for="annoImg2Input" class="block text-sm font-medium text-gray-700">Second Image URL (for comparison)</label>
            <div class="flex gap-2">
              <input type="text" id="annoImg2Input" class="flex-grow p-2 border border-gray-300 rounded-md" placeholder="https://...">
              <button id="removeImg2Btn" type="button" class="p-2 text-white bg-red-600 rounded-md hover:bg-red-700" title="Remove second image"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
            </div>
          </div>
          <button id="addImg2Btn" type="button" class="w-full px-3 py-1.5 text-sm font-medium text-gray-700 bg-white border border-dashed border-gray-400 rounded-md hover:bg-gray-100">
            + Add a second image for comparison
          </button>
        </div>
      </div>
      <div class="p-4 border-t bg-gray-50">
        <button id="saveAnnoBtn" class="w-full px-4 py-2 text-white bg-green-600 rounded-md hover:bg-green-700 font-semibold">Save Changes</button>
      </div>
    </div>
  </div>


  <script>
    const APP_STATE_KEY = 'vmaMapViewerState';
    // --- App State Management ---
    const appState = {
      map: {
        currentMapId: null,
        loadedOverlayId: null,
        loadingMapController: null,
        rotationLocked: false,
        overlayCache: {},
        view: {
          mode: 'overlay',
          sideRatio: 0.5,
          lensRadius: 150,
        },
        dragging: { sideX: false, sideY: false, lensR: false },
      },
      ui: {
        selectedFeatureId: null,
      },
      research: {
        drawInteraction: null,
        keyDownFinish: null,
        keyDownCancel: null,
        featureIdCounter: 1,
      },
      story: {
        scenes: [],
        editingSceneIndex: null,
        presentationScenes: [],
        currentPresentationIndex: -1,
        autoplayTimer: null,
        isPlaying: false,
      },
      search: {
        abortController: null,
        timer: null,
        lastSearchTime: 0,
      }
    };

    // --- Base layers ---
    const esriImageryLayer = new ol.layer.Tile({
      source: new ol.source.XYZ({
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        attributions: 'VMA Project | Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer">Esri</a>',
        crossOrigin: 'anonymous'
      }),
      visible: true,
      properties: { 'name': 'esri-imagery', 'base': true },
      zIndex: 0
    });
    const googleStreets = new ol.layer.Tile({
      source: new ol.source.XYZ({
        urls: [
          'https://mt0.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', 'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
          'https://mt2.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', 'https://mt3.google.com/vt/lyrs=m&x={x}&y={y}&z={z}'
        ],
        maxZoom: 22, crossOrigin: 'anonymous', attributions: 'VMA Project | Tiles © Google'
      }),
      visible: false, properties: { 'name': 'g-streets', 'base': true }, zIndex: 0
    });
    const googleSatellite = new ol.layer.Tile({
      source: new ol.source.XYZ({
        urls: [
          'https://mt0.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          'https://mt2.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', 'https://mt3.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'
        ],
        maxZoom: 22, crossOrigin: 'anonymous', attributions: 'VMA Project | Tiles © Google'
      }),
      visible: false, properties: { 'name': 'g-satellite', 'base': true }, zIndex: 0
    });

    // --- Overlay & Feature Layers ---
    const warpedMapLayer = new Allmaps.WarpedMapLayer({ zIndex: 10, properties: { 'name': 'allmaps-overlay' } });
    const researchSource = new ol.source.Vector();
    const researchLayer = new ol.layer.VectorImage({
      source: researchSource,
      zIndex: 20,
      imageRatio: 2,
      style: (feature) => {
        if (feature.get('hidden')) return null;
        const color = feature.get('color') || '#2563eb';
        const type = feature.getGeometry().getType();
        const label = feature.get('label') || '';
        const stroke = new ol.style.Stroke({ color: color, width: 2 });
        const fill = new ol.style.Fill({ color: color.slice(0, 7) + '26' });
        const pointBase = new ol.style.Style({ image: new ol.style.Circle({ radius: 5, fill: new ol.style.Fill({ color: color }), stroke: new ol.style.Stroke({ color: '#ffffff', width: 2 }) }) });
        const lineBase = new ol.style.Style({ stroke });
        const polyBase = new ol.style.Style({ stroke, fill });
        let styles = type === 'Point' ? [pointBase] : (type.includes('Line') ? [lineBase] : [polyBase]);
        if (label) {
          const isPoly = type.includes('Polygon');
          styles.push(new ol.style.Style({
            geometry: isPoly ? (f) => f.getGeometry().getInteriorPoint() : undefined,
            text: new ol.style.Text({
              text: label, font: '12px system-ui, Arial', fill: new ol.style.Fill({ color: '#111827' }),
              stroke: new ol.style.Stroke({ color: 'rgba(255,255,255,0.9)', width: 3 }),
              offsetY: isPoly ? 0 : -12, overflow: true
            })
          }));
        }
        return styles;
      },
      properties: { 'name': 'research' }
    });
    const searchSource = new ol.source.Vector();
    const searchLayer = new ol.layer.VectorImage({
      source: searchSource,
      zIndex: 25,
      imageRatio: 2,
      style: new ol.style.Style({
        image: new ol.style.Circle({ radius: 6, fill: new ol.style.Fill({ color: '#f59e0b' }), stroke: new ol.style.Stroke({ color: '#fff', width: 2 }) }),
        stroke: new ol.style.Stroke({ color: '#f59e0b', width: 2, lineDash: [6,4] }),
        fill: new ol.style.Fill({ color: 'rgba(245,158,11,0.12)' })
      }),
      properties: { 'name': 'search' }
    });
    
    // --- Map Initialization ---
    const map = new ol.Map({
      target: 'map',
      layers: [esriImageryLayer, googleStreets, googleSatellite, warpedMapLayer, researchLayer, searchLayer],
      view: new ol.View({
        center: ol.proj.fromLonLat([106.70098, 10.77653]),
        zoom: 14,
        enableRotation: true,
        constrainRotation: false
      }),
      controls: [
        new ol.control.Attribution({ collapsible: false }),
        new ol.control.Rotate({ autoHide: false }),
        new ol.control.Zoom(),
        new ol.control.ScaleLine()
      ]
    });
    const dragRotate  = new ol.interaction.DragRotate({ condition: ol.events.condition.platformModifierKeyOnly });
    const pinchRotate = new ol.interaction.PinchRotate();
    map.addInteraction(dragRotate);
    map.addInteraction(pinchRotate);

    // --- UI Element References ---
    // Main Layout
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebarToggleIcon = document.getElementById('sidebar-toggle-icon');
    const collapsedNav = document.getElementById('collapsed-nav');
    // Control Panel
    const basemapSel = document.getElementById('basemap');
    const zoomToMapBtn = document.getElementById('zoomToMapBtn');
    const mapSelector = document.getElementById('allmapsId');
    const mapTypeFilter = document.getElementById('mapTypeFilter');
    const customMapIdInput = document.getElementById('customMapId');
    const loadCustomBtn = document.getElementById('loadCustomBtn');
    const viewModeButtons = document.getElementById('viewModeButtons');
    const opacityRange = document.getElementById('opacityRange');
    const opLabel = document.getElementById('opLabel');
    const loader = document.getElementById('loader');
    const statusEl = document.getElementById('status');
    const metaBtn = document.getElementById('metaBtn');
    // Research Panel
    // Segmented tool buttons
    const toolModeGroup = document.getElementById('toolModeGroup');
    const toolPointBtn = document.getElementById('toolPointBtn');
    const toolLineBtn = document.getElementById('toolLineBtn');
    const toolPolyBtn = document.getElementById('toolPolyBtn');
    const toolEditBtn = document.getElementById('toolEditBtn');
    // No default selection; start with no active tool
    const researchClear = document.getElementById('researchClear');
    const annoTbody = document.getElementById('annoTbody');
    const exportCsvBtn = document.getElementById('exportCsv');
    const importCsvBtn = document.getElementById('importCsvBtn');
    const importCsvInput = document.getElementById('importCsvInput');
    const searchQuery = document.getElementById('searchQuery');
    const searchResults = document.getElementById('searchResults');
    const searchLocate = document.getElementById('searchLocate');
    const searchClearBtn = document.getElementById('searchClearBtn');
    // Story Panel
    const sceneTitleInput = document.getElementById('sceneTitleInput');
    const sceneDetailsInput = document.getElementById('sceneDetailsInput');
    const sceneDelayInput = document.getElementById('sceneDelayInput');
    const sceneAnnotationList = document.getElementById('sceneAnnotationList');
    const captureSceneBtn = document.getElementById('captureSceneBtn');
    const cancelEditBtn = document.getElementById('cancelEditBtn');
    const loadStoryBtn = document.getElementById('loadStoryBtn');
    const loadStoryInput = document.getElementById('loadStoryInput');
    const presentStoryBtn = document.getElementById('presentStoryBtn');
    const downloadStoryBtn = document.getElementById('downloadStoryBtn');
    const storyList = document.getElementById('story-list');
    // Viewport Dividers & Handles
    const dividerXEl = document.getElementById('dividerX');
    const dividerYEl = document.getElementById('dividerY');
    const dividerHandleX = document.getElementById('dividerHandleX');
    const dividerHandleY = document.getElementById('dividerHandleY');
    const lensEl = document.getElementById('lens');
    const lensHandle = document.getElementById('lensHandle');
    // Metadata Modal
    const metaModal = document.getElementById('metaModal');
    const metaLinkWrap = document.getElementById('metaLinkWrap');
    const metaSummary = document.getElementById('metaSummary');
    const closeMeta = document.getElementById('closeMeta');
    // Annotation Modal
    const annoModal = document.getElementById('annoModal');
    const closeAnnoModalBtn = document.getElementById('closeAnnoModal');
    const annoTitle = document.getElementById('annoTitle');
    const annoLabelInput = document.getElementById('annoLabelInput');
    const annoDetailsInput = document.getElementById('annoDetailsInput');
    const annoColorInput = document.getElementById('annoColorInput');
    const annoImg1Input = document.getElementById('annoImg1Input');
    const annoImg2Input = document.getElementById('annoImg2Input');
    const annoImg2Container = document.getElementById('annoImg2Container');
    const addImg2Btn = document.getElementById('addImg2Btn');
    const removeImg2Btn = document.getElementById('removeImg2Btn');
    const saveAnnoBtn = document.getElementById('saveAnnoBtn');
    // Coordinate Menu
    const coordMenu  = document.getElementById('coordMenu');
    const coordValue = document.getElementById('coordValue');
    const coordCopy  = document.getElementById('coordCopy');
    const coordClose = document.getElementById('coordClose');
    // Popup Overlay
    const popupContainer = document.getElementById('popup');
    const popupContent = document.getElementById('popup-content');
    const popupCloser = document.getElementById('popup-closer');
    // Presentation Overlay
    const presentationOverlay = document.getElementById('presentation-overlay');
    const presentationTitle = document.getElementById('presentation-title');
    const presentationDetails = document.getElementById('presentation-details');
    const presentationCounter = document.getElementById('presentation-counter');
    const presentationPrev = document.getElementById('presentation-prev');
    const presentationNext = document.getElementById('presentation-next');
    const presentationPlayPause = document.getElementById('presentation-play-pause');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const presentationExit = document.getElementById('presentation-exit');
    const clearStateBtn = document.getElementById('clearStateBtn');
    let allMapsData = [];

    // --- Sidebar & UI Functions ---
    function updateSidebarPosition() {
        const isCollapsed = sidebar.classList.contains('collapsed');
        let currentWidth;
        if (isCollapsed) {
            currentWidth = 64; // collapsed width is fixed at 64px
        } else {
            // expanded width fixed for desktop
            currentWidth = 384;
        }
        sidebarToggle.style.left = `${currentWidth - 2}px`;
    }

    function updateSidebar(isCollapsed) {
        sidebar.classList.toggle('collapsed', isCollapsed);
        sidebarToggle.classList.toggle('hidden', isCollapsed);
        if (!isCollapsed) {
            const iconPath = "M11 19l-7-7 7-7m8 14l-7-7 7-7";
            sidebarToggleIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="${iconPath}"></path>`;
            updateSidebarPosition();
        }
        setTimeout(() => map.updateSize(), 350);
    }
    function toggleSidebar() {
        updateSidebar(!sidebar.classList.contains('collapsed'));
    }
    function showTab(tabName) {
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
      document.getElementById(`panel${tabName}`).classList.remove('hidden');
    document.querySelectorAll('.tab-btn-desktop').forEach(t => t.classList.remove('active'));
    document.querySelectorAll(`.tab-btn-desktop[data-tab=\"${tabName}\"]`).forEach(t => t.classList.add('active'));
      if (sidebar.classList.contains('collapsed')) {
        updateSidebar(false);
      }
      if (tabName === 'Story') {
        const scene = appState.story.editingSceneIndex !== null ? appState.story.scenes[appState.story.editingSceneIndex] : null;
        populateSceneAnnotationList(scene ? scene.visibleFeatures : null);
      }
    }
    document.querySelectorAll('.tab-btn-desktop').forEach(button => {
      button.addEventListener('click', () => showTab(button.dataset.tab));
    });
    sidebarToggle.addEventListener('click', toggleSidebar);
    window.addEventListener('resize', updateSidebarPosition);
    collapsedNav.querySelectorAll('.collapsed-tab-btn').forEach(button => {
        button.addEventListener('click', () => {
            showTab(button.dataset.tab);
        });
    });
    mapTypeFilter.addEventListener('change', () => {
        populateMapSelector(mapTypeFilter.value);
        });

    // --- Map Control Functions ---
    function zoomToMapExtent() {
        if (!appState.map.currentMapId) return;
        const extent = warpedMapLayer.getExtent();
        if (extent && !ol.extent.isEmpty(extent)) {
            map.getView().fit(extent, { padding: [80, 80, 80, 80], duration: 500, maxZoom: 18 });
        }
    }
    function setBasemap(name) {
      [esriImageryLayer, googleStreets, googleSatellite].forEach(l => l.setVisible(l.getProperties().name === name));
    }
    basemapSel.addEventListener('change', () => { setBasemap(basemapSel.value); queueSaveState(); });
    zoomToMapBtn.addEventListener('click', zoomToMapExtent);

    function hasInteraction(i){ return map.getInteractions().getArray().includes(i); }
    function enableRotateInteractions(on){
      if (on) {
        if (!hasInteraction(dragRotate))  map.addInteraction(dragRotate);
        if (!hasInteraction(pinchRotate)) map.addInteraction(pinchRotate);
      } else {
        if (hasInteraction(dragRotate))  map.removeInteraction(dragRotate);
        if (hasInteraction(pinchRotate)) map.removeInteraction(pinchRotate);
      }
    }
    function lockRotation(lock){
      appState.map.rotationLocked = !!lock;
      const v = map.getView();
      if (appState.map.rotationLocked) {
        try { v.setRotation(0); } catch(_) {}
        enableRotateInteractions(false);
      } else {
        enableRotateInteractions(true);
      }
    }

    async function loadAllmaps(id) {
      if (!id) return;
      if (appState.map.loadingMapController) appState.map.loadingMapController.abort();
      appState.map.loadingMapController = new AbortController();
      const { signal } = appState.map.loadingMapController;

      const cache = appState.map.overlayCache;

      // If already active, just ensure opacity and bail
      if (id === appState.map.loadedOverlayId && appState.map.currentMapId) {
        const v = parseFloat(opacityRange.value);
        try { warpedMapLayer.setMapOpacity(appState.map.currentMapId, v); } catch(_) {}
        return;
      }

      // Hide current map but keep cached
      if (appState.map.currentMapId) {
        try { warpedMapLayer.setMapOpacity(appState.map.currentMapId, 0); } catch(_) {}
      }

      loader.classList.remove('hidden');
      statusEl.textContent = 'Loading map...';
      statusEl.classList.remove('text-red-600');
      metaBtn.disabled = true;
      zoomToMapBtn.disabled = true;

      const annotationUrl = `https://annotations.allmaps.org/images/${id}`;
      metaLinkWrap.innerHTML = `<a class="text-indigo-600 hover:underline" href="${annotationUrl}" target="_blank" rel="noreferrer">${annotationUrl}</a>`;

      try {
        let mapId;
        let annotation;

        if (cache[id]?.mapId) {
          ({ mapId, annotation } = cache[id]);
        } else {
          const response = await fetch(annotationUrl, { signal });
          if (!response.ok) throw new Error(`Annotation not found (HTTP ${response.status})`);
          annotation = await response.json();
          if (signal.aborted) return;
          const mapIds = await warpedMapLayer.addGeoreferenceAnnotation(annotation);
          if (signal.aborted) return;
          if (!mapIds || mapIds.length === 0 || mapIds[0] instanceof Error) throw mapIds[0] || new Error('Failed to add map to layer.');
          mapId = mapIds[0];
          cache[id] = { mapId, annotation };
        }

        appState.map.currentMapId = mapId;
        appState.map.loadedOverlayId = id;

        try { renderMetadataSummary(annotation, null, warpedMapLayer.getExtent()); } catch(_) {}
        metaBtn.disabled = false;
        zoomToMapBtn.disabled = false;
        statusEl.textContent = cache[id]?.annotation ? 'Map data received. Please wait for tiles to load.' : 'Map data received. Please wait for tiles to load.';

        const opacity = parseFloat(opacityRange.value);
        warpedMapLayer.setMapOpacity(mapId, opacity);
        queueSaveState();

      } catch (err) {
        if (err.name === 'AbortError') return;
        console.error(err);
        statusEl.textContent = `Error: ${err.message}`;
        statusEl.classList.add('text-red-600');
      } finally {
        if (!signal.aborted) {
          loader.classList.add('hidden');
          appState.map.loadingMapController = null;
        }
      }
    }
    mapSelector.addEventListener('change', () => {
      if (mapSelector.value) {
        loadAllmaps(mapSelector.value);
        customMapIdInput.value = '';
      }
    });
    const loadFromInput = () => {
      const id = customMapIdInput.value.trim();
      if (id) {
        loadAllmaps(id);
        mapSelector.value = '';
      }
    };
    loadCustomBtn.addEventListener('click', loadFromInput);
    customMapIdInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') loadFromInput(); });

    // --- Guided Tour ---
    (function(){
      const backdrop = document.getElementById('tour-backdrop');
      const highlight = document.getElementById('tour-highlight');
      const popover = document.getElementById('tour-popover');
      const titleEl = document.getElementById('tour-title');
      const textEl = document.getElementById('tour-text');
      const counterEl = document.getElementById('tour-counter');
      const btnNext = document.getElementById('tour-next');
      const btnPrev = document.getElementById('tour-prev');
      const btnSkip = document.getElementById('tour-skip');
      const btnStart = document.getElementById('startTourBtn');

      const steps = [
        { title: 'Welcome', text: 'This quick tour shows how to choose a map, add an annotation, and create a story.', selector: null, placement: 'center', ensure: () => showTab('Map') },
        { title: 'Choose a Map', text: 'Use this module to filter by map type, then pick a map from our collection. You can also add custom map from Allmaps ID.', selector: '#historicalMapModule', placement: 'right', ensure: () => showTab('Map') },
        { title: 'View & Opacity', text: 'Switch between Overlay, Side-by-Side, or Spyglass, and adjust the overlay opacity.', selector: '#viewControls', placement: 'right', ensure: () => showTab('Map') },
        { title: 'Draw Tools', text: 'You can annotate with points, lines, or polygons. Click on the map to start drawing. Press Enter to finish, Esc to cancel.', selector: '#drawTools', placement: 'right', ensure: () => showTab('Annotations') },
        { title: 'Search & Add', text: 'Or add annotation directly from a search. Search is powered by Notimatim and OpenStreetMap.', selector: '#searchModule', placement: 'right', ensure: () => showTab('Annotations') },
        { title: 'Manage Annotations', text: 'Click on the label once to zoom to the annotation, twice to edit labels. Click Edit to add details, color, and up to two images.', selector: '#annoTable', placement: 'left', ensure: () => showTab('Annotations') },
        { title: 'Capture Scene', text: 'Capture a scene to add it to your story. Each scene saves the view, overlay, and visible annotations.', selector: '#captureSceneBtn', placement: 'left', ensure: () => showTab('Story') },
        { title: 'Edit & Reorder', text: 'Use the Edit button to update a scene. To edit view and overlay, switch to Maps panel. Drag scenes to reorder them.', selector: '#story-list', placement: 'left', ensure: () => showTab('Story') },
        { title: 'Story Actions', text: 'Load an existing story, export your story to a file, or present it as an interactive.', selector: '#storyActions', placement: 'left', ensure: () => showTab('Story') }
      ];

      let index = -1;

      function show() {
        backdrop.style.display = 'block';
        popover.style.display = 'block';
        document.addEventListener('keydown', onKey);
        document.addEventListener('scroll', position, true);
        window.addEventListener('resize', position);
      }
      function hide() {
        backdrop.style.display = 'none';
        popover.style.display = 'none';
        highlight.style.display = 'none';
        document.removeEventListener('keydown', onKey);
        document.removeEventListener('scroll', position, true);
        window.removeEventListener('resize', position);
      }
      function targetEl(step) {
        if (!step.selector) return null;
        return document.querySelector(step.selector);
      }
      function position() {
        const step = steps[index];
        const el = targetEl(step);
        const padding = 8;
        const gap = 12;
        const vw = window.innerWidth, vh = window.innerHeight;
        const pw = Math.min(340, vw - 20);
        popover.style.width = pw + 'px';

        if (!el || el.offsetParent === null) {
          highlight.style.display = 'none';
          // center popover on screen if no target
          const ph = popover.offsetHeight;
          popover.style.left = (vw/2 - pw/2) + 'px';
          popover.style.top = (vh/2 - ph/2) + 'px';
          return;
        }

        const r = el.getBoundingClientRect();
        // Highlight box
        highlight.style.display = 'block';
        highlight.style.left = (Math.max(10, r.left - padding)) + 'px';
        highlight.style.top = (Math.max(10, r.top - padding)) + 'px';
        highlight.style.width = (r.width + padding*2) + 'px';
        highlight.style.height = (r.height + padding*2) + 'px';

        // Popover positioning that avoids covering the highlight
        const ph = popover.offsetHeight;

        function fits(left, top) {
          // within viewport margins
          if (left < 12 || left + pw > vw - 12) return false;
          if (top < 12 || top + ph > vh - 12) return false;
          // avoid overlapping the highlight rect (with small gap)
          const overlap = !(left + pw <= r.left - gap ||
                            left >= r.right + gap ||
                            top + ph <= r.top - gap ||
                            top >= r.bottom + gap);
          return !overlap;
        }

        // Preferred order: right, left, bottom, top
        const candidates = [];
        // right of target
        candidates.push({
          left: r.right + gap,
          top: Math.min(Math.max(12, r.top), vh - ph - 12)
        });
        // left of target
        candidates.push({
          left: r.left - pw - gap,
          top: Math.min(Math.max(12, r.top), vh - ph - 12)
        });
        // below target
        candidates.push({
          left: Math.min(Math.max(12, r.left), vw - pw - 12),
          top: r.bottom + gap
        });
        // above target
        candidates.push({
          left: Math.min(Math.max(12, r.left), vw - pw - 12),
          top: r.top - ph - gap
        });

        let placed = false;
        for (const c of candidates) {
          if (fits(c.left, c.top)) {
            popover.style.left = c.left + 'px';
            popover.style.top = c.top + 'px';
            placed = true;
            break;
          }
        }

        if (!placed) {
          // Fallback: clamp to screen near the target without strict overlap rules
          let left = Math.min(Math.max(12, r.right + gap), vw - pw - 12);
          let top = Math.min(Math.max(12, r.top), vh - ph - 12);
          popover.style.left = left + 'px';
          popover.style.top = top + 'px';
        }

        // Ensure in view for scrollable panels
        try { el.scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'smooth' }); } catch (_) {}
      }
      function setStep(i) {
        if (i < 0 || i >= steps.length) { end(); return; }
        index = i;
        const step = steps[index];
        if (typeof step.ensure === 'function') step.ensure();
        titleEl.textContent = step.title;
        textEl.textContent = step.text;
        counterEl.textContent = `Step ${index + 1} of ${steps.length}`;
        btnPrev.disabled = index === 0;
        btnNext.textContent = index === steps.length - 1 ? 'Finish' : 'Next';
        show();
        // Slight delay to allow panels to render before positioning
        setTimeout(position, 50);
      }
      function next() { setStep(index + 1); }
      function prev() { setStep(index - 1); }
      function end() { hide(); index = -1; }
      function onKey(e){ if (e.key === 'Escape') end(); if (e.key === 'ArrowRight' || e.key === 'Enter') next(); if (e.key === 'ArrowLeft') prev(); }

      if (btnStart) btnStart.addEventListener('click', () => setStep(0));
      btnNext.addEventListener('click', next);
      btnPrev.addEventListener('click', prev);
      btnSkip.addEventListener('click', end);

      // Optionally auto-suggest tour on first visit
      try {
        const seen = localStorage.getItem('vmaTourSeen');
        if (!seen) {
          // show subtle indicator by pulsing the Tour button
          btnStart?.classList.add('animate-pulse');
          btnStart?.addEventListener('click', () => localStorage.setItem('vmaTourSeen', '1'), { once: true });
        }
      } catch(_) {}
    })();

    // --- View Mode & Opacity ---
    function setViewOverlaysPointerEvents(value) {
        const elements = [dividerHandleX, dividerHandleY, lensHandle];
        elements.forEach(el => {
            if (el) el.style.pointerEvents = value;
        });
    }
    function mapSize() { return map.getSize() || [0,0]; }
    function updateClipPath() {
        const canvas = warpedMapLayer.getCanvas();
        if (!canvas) return;
        const [w, h] = mapSize();
        if (w === 0 || h === 0) return;

        if (appState.map.view.mode === 'overlay') canvas.style.clipPath = '';
        else if (appState.map.view.mode === 'side-x') canvas.style.clipPath = `polygon(${w * appState.map.view.sideRatio}px 0, ${w}px 0, ${w}px ${h}px, ${w * appState.map.view.sideRatio}px ${h}px)`;
        else if (appState.map.view.mode === 'side-y') canvas.style.clipPath = `polygon(0 ${h * appState.map.view.sideRatio}px, ${w}px ${h * appState.map.view.sideRatio}px, ${w}px ${h}px, 0 ${h}px)`;
        else if (appState.map.view.mode === 'spy') canvas.style.clipPath = `circle(${appState.map.view.lensRadius}px at ${w/2}px ${h/2}px)`;
    }
    function setMode(mode) {
      stopDrag();
      appState.map.view.mode = mode;
      if (viewModeButtons) {
          viewModeButtons.querySelectorAll('.view-mode-btn').forEach(btn => {
              btn.classList.toggle('active', btn.dataset.mode === mode);
          });
      }
      lockRotation(mode !== 'overlay');
      updateClipPath();
      updateDividersAndHandles();
      updateLensAndHandle();
      queueSaveState();
    }
    if (viewModeButtons) { viewModeButtons.addEventListener('click', (e) => { const button = e.target.closest('.view-mode-btn'); if (button && button.dataset.mode) { setMode(button.dataset.mode); } }); }
    opacityRange.addEventListener('input', () => {
      const v = parseFloat(opacityRange.value);
      opLabel.textContent = `${Math.round(v * 100)}%`;
      if (appState.map.currentMapId) {
        warpedMapLayer.setMapOpacity(appState.map.currentMapId, v);
      }
      queueSaveState();
    });
    map.on(['moveend', 'change:size'], () => {
        updateClipPath();
        updateDividersAndHandles();
        updateLensAndHandle();
    });

    function onMove(e) {
      if (!Object.values(appState.map.dragging).some(Boolean)) return;
      const rect = document.getElementById('map').getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const [w,h] = mapSize();
      if (appState.map.dragging.lensR) {
        const dx = x - w/2, dy = y - h/2;
        appState.map.view.lensRadius = Math.max(20, Math.min(Math.sqrt(dx*dx + dy*dy), Math.min(w,h)/2));
        updateLensAndHandle();
      } else if (appState.map.dragging.sideX) {
        appState.map.view.sideRatio = Math.max(0.01, Math.min(x / w, 0.99));
        updateDividersAndHandles();
      } else if (appState.map.dragging.sideY) {
        appState.map.view.sideRatio = Math.max(0.01, Math.min(y / h, 0.99));
        updateDividersAndHandles();
      }
      updateClipPath();
    }
    function stopDrag(){
      const wasDragging = Object.values(appState.map.dragging).some(Boolean);
      appState.map.dragging = { sideX:false, sideY:false, lensR:false };
      if (wasDragging) {
        queueSaveState();
      }
    }
    dividerHandleX.addEventListener('pointerdown', (e)=>{ if (appState.map.view.mode!=='side-x') return; appState.map.dragging.sideX=true; e.target.setPointerCapture(e.pointerId); e.preventDefault(); });
    dividerHandleY.addEventListener('pointerdown', (e)=>{ if (appState.map.view.mode!=='side-y') return; appState.map.dragging.sideY=true; e.target.setPointerCapture(e.pointerId); e.preventDefault(); });
    lensHandle.addEventListener('pointerdown', (e)=>{ if (appState.map.view.mode!=='spy') return; appState.map.dragging.lensR=true; e.target.setPointerCapture(e.pointerId); e.preventDefault(); });
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', stopDrag);
    window.addEventListener('pointercancel', stopDrag);

    function updateDividersAndHandles() {
        const [w, h] = mapSize();
        const showX = appState.map.view.mode === 'side-x', showY = appState.map.view.mode === 'side-y';
        dividerXEl.style.display = showX ? 'block' : 'none';
        dividerHandleX.style.display = showX ? 'block' : 'none';
        if (showX) {
            const x = w * appState.map.view.sideRatio;
            dividerXEl.style.left = x + 'px'; dividerXEl.style.height = h + 'px';
            dividerHandleX.style.left = (x - 8) + 'px'; dividerHandleX.style.top  = (h/2 - 8) + 'px';
        }
        dividerYEl.style.display = showY ? 'block' : 'none';
        dividerHandleY.style.display = showY ? 'block' : 'none';
        if (showY) {
            const y = h * appState.map.view.sideRatio;
            dividerYEl.style.top = y + 'px'; dividerYEl.style.width = w + 'px';
            dividerHandleY.style.left = (w/2 - 8) + 'px'; dividerHandleY.style.top = (y - 8) + 'px';
        }
    }
    function updateLensAndHandle() {
        const [w, h] = mapSize();
        const d = Math.max(20, appState.map.view.lensRadius * 2);
        const show = appState.map.view.mode === 'spy';
        lensEl.style.display = show ? 'block' : 'none';
        lensHandle.style.display = show ? 'block' : 'none';
        if (show) {
            lensEl.style.width=d+'px'; lensEl.style.height=d+'px';
            lensEl.style.left=(w/2 - appState.map.view.lensRadius)+'px'; lensEl.style.top=(h/2 - appState.map.view.lensRadius)+'px';
            lensHandle.style.left=(w/2 + appState.map.view.lensRadius - 8)+'px';
            lensHandle.style.top =(h/2 - 8)+'px';
        }
    }

    // --- Research/Annotation Functions ---
    const escHtml = (s) => String(s==null?'':s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    function formatLen(m){ return (m>1000)? (m/1000).toFixed(2)+' km' : m.toFixed(1)+' m'; }
    function formatArea(a){ return (a>=1e6)? (a/1e6).toFixed(2)+' km²' : a.toFixed(1)+' m²'; }
    function getOrAssignId(feat){ if (!feat.getId()){ feat.setId('a'+(appState.research.featureIdCounter++)); } return feat.getId(); }
    function metricForFeature(feat){
        const g = feat.getGeometry(); const t = g.getType();
        try{
            if (t==='Point'){
                const lonlat = ol.proj.toLonLat(g.getCoordinates());
                return lonlat[0].toFixed(5)+', '+lonlat[1].toFixed(5);
            } else if (t==='LineString'){
                return formatLen(ol.sphere.getLength(g, { projection: 'EPSG:3857' }));
            } else if (t==='Polygon'){
                return formatArea(ol.sphere.getArea(g, { projection: 'EPSG:3857' }));
            }
        } catch(_){ }
        return '—';
    }
    function refreshAnnoTable(){
        const feats = researchSource.getFeatures();
        exportCsvBtn.disabled = (feats.length === 0);
        let html = '';
        feats.forEach(f => {
            const id = getOrAssignId(f);
            const label = f.get('label') || '';
            const isHidden = f.get('hidden');
            html += `<tr data-id="${id}" class="${isHidden ? 'opacity-50 bg-gray-50' : 'bg-white'}">
                <td class="px-4 py-2">
                    <input type="text" class="anno-label w-full bg-transparent border-none focus:outline-none" value="${escHtml(label)}" readonly />
                </td>
                <td class="px-4 py-2 whitespace-nowrap space-x-1">
                    <button class="anno-edit p-1 text-green-600 hover:text-green-800" title="Edit"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>
                    <button class="anno-hide p-1 text-gray-600 hover:text-gray-800" title="${isHidden ? 'Show' : 'Hide'}">${isHidden ? '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>' : '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>'}</button>
                    <button class="anno-del p-1 text-red-600 hover:text-red-800" title="Delete"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </td></tr>`;
        });
        annoTbody.innerHTML = html || '<tr><td colspan="2" class="p-4 text-center text-gray-500">No annotations yet.</td></tr>';
        annoTbody.querySelectorAll('tr[data-id]').forEach(row => {
            const id = row.dataset.id;
            const f = researchSource.getFeatureById(id);
            if (!f) return;
            const labelInput = row.querySelector('.anno-label');
            if (labelInput) {
                let clickTimer = null;
                const clickDelay = 250; // ms to wait for a double-click
                labelInput.addEventListener('click', () => {
                    if (!labelInput.readOnly) return; // Do nothing if already in edit mode
                    if (clickTimer === null) {
                        clickTimer = setTimeout(() => {
                            clickTimer = null;
                            map.getView().fit(f.getGeometry().getExtent(), { padding:[80,80,80,80], duration: 300, maxZoom: 18 });
                        }, clickDelay);
                    } else {
                        clearTimeout(clickTimer);
                        clickTimer = null;
                        labelInput.readOnly = false;
                        labelInput.focus();
                    }
                });

                labelInput.addEventListener('blur', () => {
                    labelInput.value = (labelInput.value || '').trim();
                    f.set('label', labelInput.value);
                    researchLayer.changed();
                    queueSaveState();
                    labelInput.readOnly = true;
                });
                labelInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        labelInput.blur(); // Trigger blur to save
                    }
                });
            }
            row.querySelector('.anno-edit').addEventListener('click', () => openAnnoModal(f)); // Keep the modal edit button
            row.querySelector('.anno-hide').addEventListener('click', () => { f.set('hidden', !f.get('hidden')); researchLayer.changed(); refreshAnnoTable(); });
            row.querySelector('.anno-del').addEventListener('click', () => { researchSource.removeFeature(f); });
        });
    }
    // Modify & Snap interactions
    appState.research.modifyInteraction = null;
    appState.research.snapInteraction = null;

    function disableModify(){
        if (appState.research.modifyInteraction) map.removeInteraction(appState.research.modifyInteraction);
        if (appState.research.snapInteraction) map.removeInteraction(appState.research.snapInteraction);
        appState.research.modifyInteraction = null;
        appState.research.snapInteraction = null;
        toolEditBtn?.classList.remove('active');
        setViewOverlaysPointerEvents('auto');
    }

    function enableModify(){
        // Turn off drawing if active
        if (appState.research.drawInteraction) {
            map.removeInteraction(appState.research.drawInteraction);
            appState.research.drawInteraction = null;
        }
        document.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
        toolEditBtn?.classList.add('active');
        // Keep pointer events enabled so features are interactive
        setViewOverlaysPointerEvents('auto');
        appState.research.modifyInteraction = new ol.interaction.Modify({
            source: researchSource,
            deleteCondition: (e) => ol.events.condition.platformModifierKeyOnly(e) && ol.events.condition.singleClick(e)
        });
        appState.research.snapInteraction = new ol.interaction.Snap({ source: researchSource });
        map.addInteraction(appState.research.modifyInteraction);
        map.addInteraction(appState.research.snapInteraction);
        appState.research.modifyInteraction.on('modifyend', () => { researchLayer.changed(); queueSaveState(); });
    }

    function cleanupTool(){
        if (appState.research.drawInteraction) map.removeInteraction(appState.research.drawInteraction);
        appState.research.drawInteraction = null;
        if (appState.research.keyDownFinish) document.removeEventListener('keydown', appState.research.keyDownFinish);
        if (appState.research.keyDownCancel) document.removeEventListener('keydown', appState.research.keyDownCancel);
        disableModify();
        document.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
    }
    function setActiveTool(mode){
        cleanupTool();
        if (!mode || mode==='none') {
            setViewOverlaysPointerEvents('auto'); // Restore pointer events
            return;
        }
        
        setViewOverlaysPointerEvents('none'); // Disable pointer events to draw "through" them
        const typeMap = { point: 'Point', line: 'LineString', poly: 'Polygon' };
        if (!typeMap[mode]) return;
        // mark segmented button active
        const seg = { point: toolPointBtn, line: toolLineBtn, poly: toolPolyBtn }[mode];
        if (seg) seg.classList.add('active');

        appState.research.drawInteraction = new ol.interaction.Draw({ source: researchSource, type: typeMap[mode] });
        map.addInteraction(appState.research.drawInteraction);
        if (mode !== 'point') {
            appState.research.keyDownFinish = (e) => { if (e.key === 'Enter') { e.preventDefault(); try{ appState.research.drawInteraction.finishDrawing(); }catch(_){} } };
            document.addEventListener('keydown', appState.research.keyDownFinish);
            appState.research.keyDownCancel = (e) => { if (e.key === 'Escape') { e.preventDefault(); try{ appState.research.drawInteraction.abortDrawing(); }catch(_){} } };
            document.addEventListener('keydown', appState.research.keyDownCancel);
        }
        appState.research.drawInteraction.on('drawend', (e) => {
          getOrAssignId(e.feature);
          e.feature.set('details', '');
          e.feature.set('color', '#2563eb'); // default color
          e.feature.set('img1', '');
          e.feature.set('img2', '');
          e.feature.set('hidden', false);
          refreshAnnoTable();
          queueSaveState();
          cleanupTool();
        });
    }
    function setToolMode(mode){
        document.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
        switch(mode){
          case 'point': setActiveTool('point'); break;
          case 'line': setActiveTool('line'); break;
          case 'poly': setActiveTool('poly'); break;
          case 'edit': enableModify(); break;
          default: cleanupTool(); break;
        }
    }
    toolModeGroup.addEventListener('click', (e) => {
        const btn = e.target.closest('.seg-btn');
        if (!btn) return;
        const mode = btn.dataset.mode;
        if (!mode) return;
        if (btn.classList.contains('active')) {
            // toggle off if clicking active mode
            cleanupTool();
        } else {
            setToolMode(mode);
        }
    });
    researchSource.on(['addfeature', 'removefeature', 'clear'], () => {
        refreshAnnoTable();
        queueSaveState();
        if (!document.getElementById('panelStory').classList.contains('hidden')) {
            const scene = appState.story.editingSceneIndex !== null ? appState.story.scenes[appState.story.editingSceneIndex] : null;
            populateSceneAnnotationList(scene ? scene.visibleFeatures : null);
        }
    });
    researchClear.addEventListener('click', () => { researchSource.clear(); });

    // (Manage dropdown removed; restored direct action buttons)
    
    // --- Annotation Modal Functions ---
    function openAnnoModal(feature) {
      if (!feature) return;
      appState.ui.selectedFeatureId = feature.getId();
      annoTitle.textContent = `Edit Annotation (${appState.ui.selectedFeatureId})`;
      annoLabelInput.value = feature.get('label') || '';
      annoDetailsInput.value = feature.get('details') || '';
      annoColorInput.value = feature.get('color') || '#2563eb';
      const img1 = feature.get('img1') || '';
      const img2 = feature.get('img2') || '';
      annoImg1Input.value = img1;
      annoImg2Input.value = img2;
      if (img2) {
        annoImg2Container.classList.remove('hidden');
        addImg2Btn.classList.add('hidden');
      } else {
        annoImg2Container.classList.add('hidden');
        addImg2Btn.classList.remove('hidden');
      }
      annoModal.classList.remove('hidden');
    }
    function closeAnnoModal() {
      annoModal.classList.add('hidden');
      appState.ui.selectedFeatureId = null;
    }
    addImg2Btn.addEventListener('click', () => {
        annoImg2Container.classList.remove('hidden');
        addImg2Btn.classList.add('hidden');
    });
    removeImg2Btn.addEventListener('click', () => {
        annoImg2Input.value = '';
        annoImg2Container.classList.add('hidden');
        addImg2Btn.classList.remove('hidden');
    });
    saveAnnoBtn.addEventListener('click', () => {
      const feature = researchSource.getFeatureById(appState.ui.selectedFeatureId);
      if (!feature) return;
      feature.set('label', (annoLabelInput.value || '').trim());
      feature.set('details', (annoDetailsInput.value || '').trim());
      feature.set('color', annoColorInput.value);
      feature.set('img1', annoImg1Input.value.trim());
      feature.set('img2', annoImg2Input.value.trim());
      researchLayer.changed();
      refreshAnnoTable();
      queueSaveState();
      closeAnnoModal();
    });
    closeAnnoModalBtn.addEventListener('click', closeAnnoModal);
    annoModal.addEventListener('click', (e) => { if (e.target === annoModal) closeAnnoModal(); });

    // --- Popup Overlay & Metadata Modal ---
    const popupOverlay = new ol.Overlay({ element: popupContainer, autoPan: { animation: { duration: 250 } } });
    map.addOverlay(popupOverlay);
    popupCloser.onclick = () => { popupOverlay.setPosition(undefined); popupCloser.blur(); return false; };
    map.on('click', (evt) => {
      if (appState.research.drawInteraction) return;
      const feature = map.forEachFeatureAtPixel(evt.pixel, (f, layer) => layer === researchLayer ? f : undefined);
      if (feature && !feature.get('hidden')) {
        const label = feature.get('label');
        const details = feature.get('details');
        const img1 = feature.get('img1');
        const img2 = feature.get('img2');

        let content = `<h4 class="font-bold text-sm mb-2">${escHtml(label)}</h4><p class="text-xs max-h-16 overflow-y-auto">${escHtml(details)}</p>`;
        
        if (img1 || img2) {
          const canFlip = img1 && img2;
          const initialSrc = img1 || img2;
          content += `<img id="popup-image" src="${escHtml(initialSrc)}" alt="${escHtml(label)}" class="mt-2 rounded-md max-w-full ${canFlip ? 'cursor-pointer' : ''}" ${canFlip ? `data-img1-src="${escHtml(img1)}" data-img2-src="${escHtml(img2)}" data-state="1"` : ''}>`;
          if (canFlip) {
            content += `<div class="text-center text-xs text-gray-500 mt-1">Click image to flip</div>`;
          }
        }

        popupContent.innerHTML = content;
        popupOverlay.setPosition(evt.coordinate);

        const popupImage = document.getElementById('popup-image');
        if (popupImage && popupImage.dataset.img1Src) {
          popupImage.addEventListener('click', () => {
            const isState1 = popupImage.dataset.state === '1';
            popupImage.src = isState1 ? popupImage.dataset.img2Src : popupImage.dataset.img1Src;
            popupImage.dataset.state = isState1 ? '2' : '1';
          });
        }
      } else {
        popupOverlay.setPosition(undefined);
      }
    });

    function openMeta() { if (!metaBtn.disabled) metaModal.classList.remove('hidden'); }
    function closeMetaFn() { metaModal.classList.add('hidden'); }
    metaBtn.addEventListener('click', openMeta);
    closeMeta.addEventListener('click', closeMetaFn);
    metaModal.addEventListener('click', (e) => { if (e.target === metaModal) closeMetaFn(); });

    // --- Story Mode & Presentation ---
    function populateSceneAnnotationList(visibleIds = null) {
        const features = researchSource.getFeatures();
        if (features.length === 0) {
            sceneAnnotationList.innerHTML = '<p class="text-xs text-gray-500 p-2">No annotations available to select.</p>';
            return;
        }
        sceneAnnotationList.innerHTML = '';

        features.forEach(f => {
            const id = f.getId();
            const label = f.get('label') || `Feature ${id}`;
            const isChecked = (visibleIds === null) ? !f.get('hidden') : visibleIds.includes(id);
            const div = document.createElement('div');
            div.className = 'flex items-center';
            div.innerHTML = `
                <input type="checkbox" id="anno-check-${id}" value="${id}" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" ${isChecked ? 'checked' : ''}>
                <label for="anno-check-${id}" class="ml-2 block text-sm text-gray-900 truncate" title="${escHtml(label)}">${escHtml(label)}</label>
            `;
            sceneAnnotationList.appendChild(div);
        });
    }

    async function applyScene(scene) {
        if (!scene) return;
        setBasemap(scene.basemap);
        basemapSel.value = scene.basemap;
        if (scene.overlayId && scene.overlayId !== appState.map.loadedOverlayId) {
            await loadAllmaps(scene.overlayId);
        } else if (!scene.overlayId && appState.map.currentMapId) {
            // Hide current overlay but keep it cached to avoid reloads later
            try { warpedMapLayer.setMapOpacity(appState.map.currentMapId, 0); } catch(_) {}
            appState.map.currentMapId = null;
            appState.map.loadedOverlayId = null;
            metaBtn.disabled = true;
            zoomToMapBtn.disabled = true;
        }
        if (scene.overlayId && appState.map.currentMapId) {
            mapSelector.value = scene.overlayId;
            opacityRange.value = scene.opacity;
            opLabel.textContent = `${Math.round(scene.opacity * 100)}%`;
            warpedMapLayer.setMapOpacity(appState.map.currentMapId, scene.opacity);
        } else {
            mapSelector.value = '';
        }
        appState.map.view.sideRatio = scene.sideRatio || 0.5;
        appState.map.view.lensRadius = scene.lensRadius || 150;
        setMode(scene.viewMode || 'overlay');
        const animOpts = { center: scene.center, zoom: scene.zoom, duration: 1200, easing: ol.easing.inAndOut };
        if ((scene.viewMode || 'overlay') === 'overlay') animOpts.rotation = scene.rotation || 0;
        map.getView().animate(animOpts);
        researchSource.getFeatures().forEach(f => f.set('hidden', !scene.visibleFeatures.includes(f.getId())));
        researchLayer.changed();
        if (document.getElementById('panelAnnotations') && !document.getElementById('panelAnnotations').classList.contains('hidden')) {
          refreshAnnoTable();
        }
    }
    function renderStoryPanel() {
        storyList.innerHTML = '';
        const scenes = appState.story.scenes;
        if (scenes.length === 0) {
            storyList.innerHTML = `<li class="p-4 text-center text-gray-500" id="story-placeholder">No scenes captured yet.</li>`;
            downloadStoryBtn.disabled = true;
            presentStoryBtn.disabled = true;
            return;
        }
        downloadStoryBtn.disabled = false;
        presentStoryBtn.disabled = scenes.filter(s => !s.hidden).length === 0;
        scenes.forEach((scene, index) => {
            const li = document.createElement('li');
            const isHidden = !!scene.hidden;
            li.className = `p-3 flex items-center gap-3 cursor-move ${isHidden ? 'opacity-60 bg-gray-100' : ''}`;
            li.draggable = true;
            li.dataset.index = index;
            li.innerHTML = `<span class="flex-grow font-semibold text-gray-700 truncate" title="${escHtml(scene.title)}">${escHtml(scene.title)}</span>`;
            
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'flex items-center gap-1 flex-shrink-0';

            const editBtn = document.createElement('button');
            editBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>`;
            editBtn.className = 'p-1.5 text-green-600 hover:bg-green-100 rounded-md';
            editBtn.title = 'Edit Scene';
            editBtn.onclick = (e) => { e.stopPropagation(); enterEditMode(index); };

            const duplicateBtn = document.createElement('button');
            duplicateBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>`;
            duplicateBtn.className = 'p-1.5 text-blue-600 hover:bg-blue-100 rounded-md';
            duplicateBtn.title = 'Duplicate Scene';
            duplicateBtn.onclick = (e) => {
                e.stopPropagation();
                const sceneToCopy = appState.story.scenes[index];
                const newScene = JSON.parse(JSON.stringify(sceneToCopy));
                newScene.title = `${newScene.title} (Copy)`;
                appState.story.scenes.splice(index + 1, 0, newScene);
                renderStoryPanel();
            };

            const hideBtn = document.createElement('button');
            hideBtn.innerHTML = isHidden 
                ? `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>` 
                : `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;
            hideBtn.className = 'p-1.5 text-gray-600 hover:bg-gray-200 rounded-md';
            hideBtn.title = isHidden ? 'Show in Presentation' : 'Hide from Presentation';
            hideBtn.onclick = (e) => { e.stopPropagation(); scene.hidden = !isHidden; renderStoryPanel(); };

            const delBtn = document.createElement('button');
            delBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>`;
            delBtn.className = 'p-1.5 text-red-600 hover:bg-red-100 rounded-md';
            delBtn.title = 'Delete Scene';
            delBtn.onclick = (e) => {
                e.stopPropagation();
                if (appState.story.editingSceneIndex === index) exitEditMode();
                scenes.splice(index, 1);
                renderStoryPanel();
            };
            actionsDiv.appendChild(editBtn);
            actionsDiv.appendChild(duplicateBtn);
            actionsDiv.appendChild(hideBtn);
            actionsDiv.appendChild(delBtn);
            li.appendChild(actionsDiv);
            storyList.appendChild(li);
        });
        queueSaveState();
    }
    captureSceneBtn.addEventListener('click', () => {
        const view = map.getView();
        const visibleFeatures = Array.from(sceneAnnotationList.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
        const scene = {
            title: sceneTitleInput.value.trim(),
            details: sceneDetailsInput.value.trim(),
            delay: parseInt(sceneDelayInput.value, 10) || 5,
            center: view.getCenter(), zoom: view.getZoom(), rotation: view.getRotation(),
            basemap: basemapSel.value, overlayId: appState.map.loadedOverlayId,
            opacity: parseFloat(opacityRange.value), viewMode: appState.map.view.mode,
            sideRatio: appState.map.view.sideRatio, lensRadius: appState.map.view.lensRadius,
            visibleFeatures: visibleFeatures,
            hidden: appState.story.editingSceneIndex !== null ? appState.story.scenes[appState.story.editingSceneIndex].hidden : false
        };
        if (appState.story.editingSceneIndex !== null) {
            // Editing: if new title is empty, keep the old one.
            if (!scene.title) {
                scene.title = appState.story.scenes[appState.story.editingSceneIndex].title;
            }
            appState.story.scenes[appState.story.editingSceneIndex] = scene;
            exitEditMode();
        } else {
            // Creating: if title is empty, generate a default one.
            if (!scene.title) {
                scene.title = `Scene ${appState.story.scenes.length + 1}`;
            }
            appState.story.scenes.push(scene);
            sceneTitleInput.value = '';
            sceneDetailsInput.value = '';
            sceneDelayInput.value = '5';
        }
        renderStoryPanel();
    });
    function enterEditMode(index) {
        const scene = appState.story.scenes[index];
        if (!scene) return;
        appState.story.editingSceneIndex = index;
        applyScene(scene);
        sceneTitleInput.value = scene.title || '';
        sceneDetailsInput.value = scene.details || '';
        sceneDelayInput.value = scene.delay || 5;
        captureSceneBtn.textContent = 'Save Changes';
        captureSceneBtn.classList.replace('bg-blue-600', 'bg-green-600');
        cancelEditBtn.classList.remove('hidden');
        populateSceneAnnotationList(scene.visibleFeatures);
    }
    function exitEditMode() {
        appState.story.editingSceneIndex = null;
        sceneTitleInput.value = '';
        sceneDetailsInput.value = '';
        sceneDelayInput.value = '5';
        captureSceneBtn.textContent = 'Capture Scene';
        captureSceneBtn.classList.replace('bg-indigo-600', 'bg-indigo-600');
        cancelEditBtn.classList.add('hidden');
        populateSceneAnnotationList();
    }
    cancelEditBtn.addEventListener('click', exitEditMode);
    downloadStoryBtn.addEventListener('click', () => {
        if (appState.story.scenes.length === 0) return;
        const geoJsonFormat = new ol.format.GeoJSON();
        const featuresGeoJson = geoJsonFormat.writeFeaturesObject(researchSource.getFeatures(), { featureProjection: 'EPSG:3857' });
        const storyData = { features: featuresGeoJson, scenes: appState.story.scenes };
        const blob = new Blob([JSON.stringify(storyData, null, 2)], { type: 'application/json;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `story-${new Date().toISOString().replace(/[:.]/g, '-')}.json`; a.click();
        URL.revokeObjectURL(url);
    });
    loadStoryBtn.addEventListener('click', () => loadStoryInput.click());
    loadStoryInput.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            try {
                const loadedData = JSON.parse(String(reader.result || '{}'));
                if (loadedData && loadedData.features && Array.isArray(loadedData.scenes)) {
                    researchSource.clear();
                    // Assign titles to untitled scenes to make them stable
                    loadedData.scenes.forEach((scene, i) => {
                        if (!scene.title) {
                            scene.title = `Scene ${i + 1}`;
                        }
                    });
                    const features = new ol.format.GeoJSON().readFeatures(loadedData.features, { featureProjection: 'EPSG:3857' });
                    researchSource.addFeatures(features);
                    appState.story.scenes = loadedData.scenes;
                    renderStoryPanel();
                } else { alert('Invalid story file format.'); }
            } catch (err) { alert('Could not parse story file.'); }
            loadStoryInput.value = '';
        };
        reader.readAsText(file);
    });

    // --- Story Drag & Drop ---
    let dragStartIndex;
    storyList.addEventListener('dragstart', (e) => {
        const target = e.target.closest('li[draggable="true"]');
        if (target) {
            dragStartIndex = parseInt(target.dataset.index, 10);
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => target.classList.add('opacity-30'), 0);
        }
    });
    storyList.addEventListener('dragend', (e) => {
        e.target.closest('li[draggable="true"]')?.classList.remove('opacity-30');
        dragStartIndex = undefined;
    });
    storyList.addEventListener('dragover', (e) => {
        e.preventDefault(); // This is necessary to allow a drop
    });
    storyList.addEventListener('drop', (e) => {
        e.preventDefault();
        const dropTarget = e.target.closest('li[draggable="true"]');
        if (dropTarget && typeof dragStartIndex === 'number') {
            const dropIndex = parseInt(dropTarget.dataset.index, 10);
            if (dragStartIndex !== dropIndex) {
                const [movedItem] = appState.story.scenes.splice(dragStartIndex, 1);
                appState.story.scenes.splice(dropIndex, 0, movedItem);
                renderStoryPanel();
            }
        }
    });

    async function showSlide(index) {
        if (index < 0 || index >= appState.story.presentationScenes.length) return;
        popupOverlay.setPosition(undefined);
        appState.story.currentPresentationIndex = index;
        const scene = appState.story.presentationScenes[index];
        await applyScene(scene);
        presentationTitle.textContent = scene.title || `Scene ${index + 1}`;
        presentationDetails.textContent = scene.details || '';
        presentationCounter.textContent = `${index + 1} / ${appState.story.presentationScenes.length}`;
        presentationPrev.disabled = index === 0;
        presentationNext.disabled = index === appState.story.presentationScenes.length - 1;
    }
    function pauseAutoplay() {
        if (!appState.story.isPlaying && !appState.story.autoplayTimer) return;
        appState.story.isPlaying = false;
        if (appState.story.autoplayTimer) {
            clearTimeout(appState.story.autoplayTimer);
            appState.story.autoplayTimer = null;
        }
        playIcon.classList.remove('hidden');
        pauseIcon.classList.add('hidden');
    }
    async function playAutoplay() {
        if (appState.story.isPlaying) return;

        // If at the end, restart from the beginning.
        if (appState.story.currentPresentationIndex >= appState.story.presentationScenes.length - 1) {
            appState.story.currentPresentationIndex = -1;
        }

        appState.story.isPlaying = true;
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');

        async function next() {
            if (!appState.story.isPlaying) return;
            const nextIndex = appState.story.currentPresentationIndex + 1;
            if (nextIndex < appState.story.presentationScenes.length) {
                await showSlide(nextIndex);
                if (appState.story.isPlaying) { // Check again in case it was paused during await
                    if (nextIndex >= appState.story.presentationScenes.length - 1) {
                        pauseAutoplay(); // Reached the end
                        return;
                    }
                    const currentScene = appState.story.presentationScenes[nextIndex];
                    const delay = (currentScene.delay || 2) * 1000;
                    appState.story.autoplayTimer = setTimeout(next, delay);
                }
            } else {
                pauseAutoplay(); // Autoplay ends
            }
        }
        if (appState.story.currentPresentationIndex === -1) {
            next(); // Start immediately if we're restarting
        } else {
            const currentScene = appState.story.presentationScenes[appState.story.currentPresentationIndex];
            const initialDelay = (currentScene?.delay || 2) * 1000;
            appState.story.autoplayTimer = setTimeout(next, initialDelay);
        }
    }
    function startPresentation() {
        appState.story.presentationScenes = appState.story.scenes.filter(s => !s.hidden);
        if (appState.story.presentationScenes.length === 0) return;
        updateSidebar(true); // Collapse sidebar for presentation
        presentationOverlay.classList.remove('hidden');
        pauseAutoplay(); // Reset autoplay state
        showSlide(0);
    }
    function exitPresentation() {
        pauseAutoplay();
        presentationOverlay.classList.add('hidden');
        appState.story.currentPresentationIndex = -1;
        appState.story.presentationScenes = [];
    }
    presentStoryBtn.addEventListener('click', startPresentation);
    presentationNext.addEventListener('click', () => { pauseAutoplay(); showSlide(appState.story.currentPresentationIndex + 1); });
    presentationPrev.addEventListener('click', () => { pauseAutoplay(); showSlide(appState.story.currentPresentationIndex - 1); });
    presentationPlayPause.addEventListener('click', () => { if (appState.story.isPlaying) pauseAutoplay(); else playAutoplay(); });
    presentationExit.addEventListener('click', exitPresentation);
    document.addEventListener('keydown', (e) => {
        if (presentationOverlay.classList.contains('hidden')) return;
        if (e.key === 'ArrowRight') { pauseAutoplay(); showSlide(appState.story.currentPresentationIndex + 1); }
        else if (e.key === 'ArrowLeft') { pauseAutoplay(); showSlide(appState.story.currentPresentationIndex - 1); }
        else if (e.key === 'Escape') exitPresentation();
    });

    // --- Search Logic (in Research Panel) ---
    function renderSearchItems(items){
        if (!items || !items.length){ searchResults.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">No results found.</div>'; return; }
        searchResults.innerHTML = '';
        items.forEach((it) => {
            const div = document.createElement('div');
            div.className = 'p-2 border-b border-gray-200 cursor-pointer hover:bg-gray-100 flex items-center gap-2';
            const title = escHtml(it.display_name || `${it.type || ''}`);
            div.innerHTML = `<div class="flex-grow min-w-0"><div class="font-semibold text-sm text-gray-800 truncate">${title}</div></div><button type="button" class="add-search-btn px-2 py-1 text-xs font-semibold text-white bg-indigo-600 rounded-md hover:bg-indigo-700">Add</button>`;
            div.addEventListener('click', (e) => { if(!e.target.classList.contains('add-search-btn')) zoomToSearchResult(it); });
            div.querySelector('.add-search-btn').addEventListener('click', (ev) => { ev.stopPropagation(); addResultToAnnotations(it); });
            searchResults.appendChild(div);
        });
    }
    function createFeatureFromSearchResult(it) {
        try {
            let feat = null;
            if (it.geojson) feat = new ol.format.GeoJSON().readFeature({ type: 'Feature', geometry: it.geojson }, { dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857' });
            else if (it.lat && it.lon) feat = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.fromLonLat([Number(it.lon), Number(it.lat)])) });
            if (feat) feat.set('label', it.display_name || it.name || '');
            return feat;
        } catch (e) { console.warn("Could not create feature from search result:", e); return null; }
    }
    function zoomToSearchResult(it) {
        searchSource.clear();
        const feat = createFeatureFromSearchResult(it);
        if (!feat) return;
        searchSource.addFeature(feat);
        const geom = feat.getGeometry();
        if (geom.getType() === 'Point') map.getView().animate({ center: geom.getCoordinates(), duration: 400, zoom: Math.max(map.getView().getZoom() || 12, 16) });
        else map.getView().fit(geom.getExtent(), { padding: [80, 80, 80, 80], duration: 400, maxZoom: 18 });
    }
    function addResultToAnnotations(it) {
        const feat = createFeatureFromSearchResult(it);
        if (!feat) return;
        researchSource.addFeature(feat);
        searchSource.clear();
        searchResults.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">Feature added to annotations.</div>';
        searchQuery.value = '';
    }
    const MIN_SEARCH_INTERVAL = 1000;
    async function runSearchNow() {
        const q = (searchQuery?.value || '').trim();
        if (!q) { searchResults.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">Enter a place or address to search.</div>'; return; }
        if (appState.search.abortController) appState.search.abortController.abort();
        appState.search.abortController = new AbortController();
        searchResults.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">Searching...</div>';
        try {
            const params = new URLSearchParams({ format: 'jsonv2', q, addressdetails: '1', polygon_geojson: '1', limit: '10' });
            const res = await fetch(`https://nominatim.openstreetmap.org/search?${params}`, { signal: appState.search.abortController.signal });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            renderSearchItems(await res.json());
        } catch (err) {
            if (err.name !== 'AbortError') searchResults.innerHTML = '<div class="p-4 text-center text-sm text-red-600">Search failed.</div>';
        }
    }
    function queueSearch() {
        if (appState.search.timer) clearTimeout(appState.search.timer);
        const now = Date.now();
        const wait = Math.max(0, MIN_SEARCH_INTERVAL - (now - appState.search.lastSearchTime));
        appState.search.timer = setTimeout(() => { appState.search.lastSearchTime = now; runSearchNow(); }, wait + 400);
    }
    searchQuery.addEventListener('input', queueSearch);
    if (searchClearBtn) {
        searchClearBtn.addEventListener('click', () => {
            searchQuery.value = '';
            searchSource.clear();
            searchResults.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">Enter a place or address to search.</div>';
            if (appState.search.abortController) appState.search.abortController.abort();
        });
    }
    searchLocate.addEventListener('click', () => {
        if (!('geolocation' in navigator)) { alert('Geolocation is not supported.'); return; }
        searchResults.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">Locating...</div>';
        navigator.geolocation.getCurrentPosition(pos => {
            const center = ol.proj.fromLonLat([pos.coords.longitude, pos.coords.latitude]);
            searchSource.clear();
            searchSource.addFeature(new ol.Feature({ geometry: new ol.geom.Point(center) }));
            map.getView().animate({ center, duration: 500, zoom: Math.max(map.getView().getZoom() || 12, 16) });
            searchResults.innerHTML = '<div class="p-4 text-center text-sm text-green-600">Centered on your location.</div>';
        }, err => {
            searchResults.innerHTML = `<div class="p-4 text-center text-sm text-red-600">Could not get location: ${err.message}</div>`;
        });
    });

    // --- CSV Import/Export Functions ---
    const geoJsonFormat = new ol.format.GeoJSON();
    function csvEscape(val) {
        if (val == null) return '';
        const s = String(val);
        if (/[,"\n\r]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
        return s;
    }
    function featureToCsvRow(f) {
        const geojson = JSON.stringify(geoJsonFormat.writeGeometryObject(f.getGeometry(), { featureProjection: 'EPSG:3857' }));
        return [f.getId() || '', f.getGeometry().getType(), f.get('label') || '', f.get('details') || '', f.get('color') || '#2563eb', f.get('img1') || '', f.get('img2') || '', geojson].map(csvEscape).join(',');
    }
    function downloadGeoJSON() {
        const format = new ol.format.GeoJSON();
        // Write as true GeoJSON in EPSG:4326 for GIS compatibility
        const featureCollection = format.writeFeaturesObject(
            researchSource.getFeatures(),
            { featureProjection: 'EPSG:3857', dataProjection: 'EPSG:4326' }
        );
        const blob = new Blob([JSON.stringify(featureCollection, null, 2)], { type: 'application/geo+json;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `annotations-${new Date().toISOString().replace(/[:.]/g, '-')}.geojson`;
        a.click();
        URL.revokeObjectURL(url);
    }
    function parseCsvLine(line) {
        const out = []; let cur = ''; let i = 0; let inQ = false;
        while (i < line.length) {
            const ch = line[i++];
            if (inQ) { if (ch === '"') { if (i < line.length && line[i] === '"') { cur += '"'; i++; } else { inQ = false; } } else { cur += ch; } }
            else { if (ch === ',') { out.push(cur); cur = ''; } else if (ch === '"') { inQ = true; } else { cur += ch; } }
        }
        out.push(cur);
        return out;
    }
    function importGeoJSON(text) {
        let json;
        try { json = JSON.parse(text); } catch (_) { alert('Invalid GeoJSON file.'); return; }
        try {
            const format = new ol.format.GeoJSON();
            const feats = format.readFeatures(json, { dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857' });
            feats.forEach(f => { getOrAssignId(f); });
            researchSource.addFeatures(feats);
            refreshAnnoTable();
            queueSaveState();
        } catch (e) {
            console.error(e);
            alert('Failed to import GeoJSON.');
        }
    }
    function importCsv(text) {
        const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
        if (!lines.length) return;
        const header = parseCsvLine(lines.shift()).map(h => h.trim().toLowerCase());
        const geojsonIndex = header.indexOf('geojson');
        if (geojsonIndex === -1) { alert("Import failed: CSV must contain a 'geojson' column."); return; }
        const colMap = { id: 'id', label: 'label', details: 'details', color: 'color', img1: 'img1', img2: 'img2' };
        for (const line of lines) {
            const cols = parseCsvLine(line);
            if (!cols[geojsonIndex]) continue;
            try {
                const geom = geoJsonFormat.readGeometry(JSON.parse(cols[geojsonIndex]), { featureProjection: 'EPSG:3857' });
                const feat = new ol.Feature({ geometry: geom });
                for (const prop in colMap) {
                    const idx = header.indexOf(prop);
                    if (idx !== -1 && cols[idx]) {
                        if (prop !== 'id') feat.set(prop, cols[idx]);
                    }
                }
                let id = cols[header.indexOf('id')]?.trim();
                if (id) feat.setId(id); else getOrAssignId(feat);
                researchSource.addFeature(feat);
            } catch (_) {}
        }
    }
    exportCsvBtn.addEventListener('click', downloadGeoJSON);
    importCsvBtn.addEventListener('click', () => importCsvInput.click());
    importCsvInput.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            const text = String(reader.result || '');
            const name = (file.name || '').toLowerCase();
            if (name.endsWith('.geojson') || name.endsWith('.json') || /^\s*\{/.test(text)) {
                importGeoJSON(text);
            } else {
                importCsv(text);
            }
            importCsvInput.value = '';
        };
        reader.readAsText(file);
    });

    // --- Right-click & Utility Functions ---
    function hideCoordMenu(){ if (coordMenu) coordMenu.classList.add('hidden'); }
    map.getViewport().addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const coord = map.getCoordinateFromPixel(map.getEventPixel(e));
        if (!coord) return;
        const [lon, lat] = ol.proj.toLonLat(coord, 'EPSG:3857');
        coordValue.textContent = `${lon.toFixed(6)}, ${lat.toFixed(6)}`;
        coordMenu.classList.remove('hidden');
        coordMenu.style.left = `${e.clientX + 4}px`;
        coordMenu.style.top = `${e.clientY + 4}px`;
    });
    async function doCopy(el, val){
        if (!val || val === '—') return;
        await navigator.clipboard.writeText(val);
        const old = el.textContent;
        el.textContent = 'Copied!';
        setTimeout(() => el.textContent = old, 900);
    }
    coordCopy.addEventListener('click', () => doCopy(coordCopy, coordValue.textContent));
    coordValue.addEventListener('click', () => doCopy(coordValue, coordValue.textContent));
    coordClose.addEventListener('click', hideCoordMenu);
    document.addEventListener('pointerdown', (e) => { if (!coordMenu.classList.contains('hidden') && !coordMenu.contains(e.target)) hideCoordMenu(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') { hideCoordMenu(); closeMetaFn(); closeAnnoModal(); exitPresentation(); } });
    if (clearStateBtn) {
        clearStateBtn.addEventListener('click', () => {
            if (!confirm('Clear all saved data, maps, and reload? This cannot be undone.')) return;
            try {
                // Clear localStorage keys used by the app
                localStorage.removeItem(APP_STATE_KEY);
                localStorage.removeItem('vmaTourSeen');
            } catch(_) {}
            try { saveStateTimer && clearTimeout(saveStateTimer); } catch(_) {}
            
            // Clear annotations and story
            try { researchSource.clear(); } catch(_) {}
            try { appState.story.scenes = []; renderStoryPanel(); } catch(_) {}

            // Clear overlays and caches
            try { warpedMapLayer.clear(); } catch(_) {}
            try { warpedMapLayerB.clear(); } catch(_) {}
            try {
                appState.map.overlayCache = {};
                appState.map.overlayA = { id: null, mapId: null };
                appState.map.overlayB = { id: null, mapId: null };
                appState.map.currentMapId = null;
                appState.map.loadedOverlayId = null;
            } catch(_) {}

            // Reset compare and UI selections
            try {
                if (compareToggle) { compareToggle.checked = false; appState.map.compare.enabled = false; appState.map.compare.flip = false; }
                if (mapSelector) mapSelector.value = '';
                if (mapSelectorB) mapSelectorB.value = '';
                if (customMapIdInput) customMapIdInput.value = '';
                updateOverlayOrder?.();
                updateBasemapVisibility?.();
                updateClipPath?.();
                updateSwapButtonState?.();
                updateOpacityTargetNote?.();
            } catch(_) {}

            // Attempt to clear IndexedDB databases for this origin (best-effort)
            try {
                if (indexedDB && indexedDB.databases) {
                    indexedDB.databases().then(dbs => {
                        try { dbs.forEach(db => db && db.name && indexedDB.deleteDatabase(db.name)); } catch(_) {}
                    }).finally(() => setTimeout(() => location.reload(), 50));
                    return; // reload scheduled above
                }
            } catch(_) {}

            // Fallback reload
            setTimeout(() => location.reload(), 50);
        });
    }

    // --- Metadata Summary Renderer ---
    function renderMetadataSummary(annotation, feature, extent3857) {
      const props = annotation || {};
      const extent4326 = extent3857 ? ol.proj.transformExtent(extent3857, 'EPSG:3857', 'EPSG:4326') : null;
      const fmtDate = (d) => { try { return new Date(d).toLocaleString(); } catch { return d; } };
      const rows = [];
      const addRow = (k, v) => v && rows.push(`<div class="font-semibold text-gray-600">${k}</div><div class="break-words">${v}</div>`);
      addRow('Type', props.type);
      addRow('Created', fmtDate(props.created));
      if (props.resource?.id) addRow('Resource', `<a class="text-indigo-600 hover:underline" href="${escHtml(props.resource.id)}" target="_blank">${escHtml(props.resource.id)}</a>`);
      if (props.resource?.width) addRow('Dimensions', `${props.resource.width} x ${props.resource.height} px`);
      if (extent4326) addRow('Extent (lon/lat)', `${extent4326[0].toFixed(4)}, ${extent4326[1].toFixed(4)} → ${extent4326[2].toFixed(4)}, ${extent4326[3].toFixed(4)}`);
      metaSummary.innerHTML = `<div class="grid grid-cols-[max-content,1fr] gap-x-4 gap-y-2">${rows.join('')}</div>`;
    }

    // --- State Persistence ---
    function saveAppState() {
        try {
            const state = {
                basemap: basemapSel.value,
                overlayId: appState.map.loadedOverlayId,
                view: {
                    ...appState.map.view,
                    opacity: parseFloat(opacityRange.value)
                },
                mapView: {
                    center: map.getView().getCenter(),
                    zoom: map.getView().getZoom(),
                    rotation: map.getView().getRotation()
                },
                annotations: geoJsonFormat.writeFeaturesObject(researchSource.getFeatures(), { featureProjection: 'EPSG:3857' }),
                story: appState.story.scenes
            };
            localStorage.setItem(APP_STATE_KEY, JSON.stringify(state));
        } catch (e) {
            console.error("Failed to save app state:", e);
        }
    }
    let saveStateTimer = null;
    function queueSaveState() {
        if (saveStateTimer) clearTimeout(saveStateTimer);
        saveStateTimer = setTimeout(saveAppState, 1000);
    }
    // Ensure state is flushed on page unload
    window.addEventListener('beforeunload', () => {
        try { if (saveStateTimer) { clearTimeout(saveStateTimer); saveAppState(); } } catch(_) {}
    });
    async function loadAppState() {
        const savedStateJSON = localStorage.getItem(APP_STATE_KEY);
        if (!savedStateJSON) return;
        try {
            const state = JSON.parse(savedStateJSON);
            if (state.mapView) map.getView().setProperties(state.mapView);
            if (state.annotations) researchSource.addFeatures(new ol.format.GeoJSON().readFeatures(state.annotations, { featureProjection: 'EPSG:3857' }));
            if (state.story) appState.story.scenes = state.story;
            if (state.basemap) { setBasemap(state.basemap); basemapSel.value = state.basemap; }
            if (state.view) {
                appState.map.view.sideRatio = state.view.sideRatio || 0.5;
                appState.map.view.lensRadius = state.view.lensRadius || 150;
                setMode(state.view.mode || 'overlay');
                const opacity = state.view.opacity || 0.8;
                opacityRange.value = opacity;
                opLabel.textContent = `${Math.round(opacity * 100)}%`;
            }
            if (state.overlayId) {
                mapSelector.value = state.overlayId;
                await loadAllmaps(state.overlayId);
                if (state.view?.opacity && appState.map.currentMapId) {
                    warpedMapLayer.setMapOpacity(appState.map.currentMapId, state.view.opacity);
                }
            }
        } catch (e) {
            console.error("Failed to load app state:", e);
            localStorage.removeItem(APP_STATE_KEY);
        }
    }

    // --- App Initialization ---
    function populateMapSelector(filterType = 'all') {
        const filteredMaps = filterType === 'all'
            ? allMapsData
            : allMapsData.filter(m => m.type === filterType);

        mapSelector.innerHTML = '<option value="" disabled selected>Select a map from the list...</option>';
        filteredMaps.forEach(map => {
            const option = document.createElement('option');
            option.value = map.id;
            option.textContent = map.name;
            mapSelector.appendChild(option);
        });
    }

    function populateTypeFilter() {
        const typeCounts = allMapsData.reduce((counts, map) => {
            if (map.type) {
                counts[map.type] = (counts[map.type] || 0) + 1;
            }
            return counts;
        }, {});

        const sortedTypes = Object.keys(typeCounts).sort();

        mapTypeFilter.innerHTML = `<option value="all" selected>All Types (${allMapsData.length})</option>`;
        sortedTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = `${type} (${typeCounts[type]})`;
            mapTypeFilter.appendChild(option);
        });
    }

    async function loadAndParseMapDataset() {
      const googleSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQivs6N80xA_Pgs0J8MMMTGcH4YLzjhhyxPUoMcoQTxHjUyRXo5FMOICXDSxayDcLYisABkoqvXiIiA/pub?gid=0&single=true&output=csv';
      try {
        const response = await fetch(googleSheetUrl);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const csvText = await response.text();
        const lines = csvText.trim().split(/\r?\n/);
        const header = lines.shift().split(',').map(h => h.trim().toLowerCase());
        const nameIndex = header.indexOf('name');
        const idIndex = header.indexOf('id');
        const typeIndex = header.indexOf('type');
        if (nameIndex === -1 || idIndex === -1) throw new Error("CSV must have 'name' and 'id' columns.");

        allMapsData = lines.map(line => {
          const values = line.match(/(".*?"|[^",\r\n]+)(?=\s*,|\s*$)/g) || [];
          const name = (values[nameIndex] || '').replace(/"/g, '').trim();
          const id = (values[idIndex] || '').replace(/"/g, '').trim();
          const type = typeIndex > -1 ? (values[typeIndex] || '').replace(/"/g, '').trim() : 'Uncategorized';
          return (name && id) ? { name, id, type } : null;
        }).filter(Boolean);

        populateTypeFilter();
        populateMapSelector('all');
      } catch (error) {
        console.error("Could not load map dataset:", error);
        if (statusEl) {
          statusEl.textContent = 'Failed to load map list.';
          statusEl.classList.add('text-red-600');
        }
      }
    }
    async function loadFromUrlOrDefault() {
        const qid = new URL(location.href).searchParams.get('id');
        if (qid && qid !== appState.map.loadedOverlayId) {
            mapSelector.value = qid;
            await loadAllmaps(qid);
            return;
        }
        if (!appState.map.loadedOverlayId) {
            const firstMapId = mapSelector.options[1]?.value;
            if (firstMapId) {
                mapSelector.value = firstMapId;
                await loadAllmaps(firstMapId);
            }
        }
    }

    // --- Initial Run ---
    updateSidebar(false);
    showTab('Map');
    loadAndParseMapDataset().then(() => loadAppState()).then(() => loadFromUrlOrDefault()).then(() => {
        refreshAnnoTable(); renderStoryPanel();
    }).catch(console.error);
    
  </script>
</body>
</html>
