<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VMA Map Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.5.2/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v7.5.2/dist/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@allmaps/openlayers/dist/bundled/allmaps-openlayers-8.umd.js"></script>
  <style>
    /* Map logo */
    .map-logo { position: absolute; top: 10px; left: 10px; z-index: 1100; width: 60px; height: auto; border-radius: 8px; background: rgba(255,255,255,0.75); padding: 4px 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); pointer-events: none; }
    /* Reposition OpenLayers controls: zoom at top-right, rotate (north-up) below it (closer together) */
    .ol-zoom { top: 10px; right: 10px; left: auto; display: flex; flex-direction: column; gap: var(--ctlGap); z-index: 1100; }
    .ol-rotate { top: calc(10px + (var(--ctlSz) * 2) + var(--ctlGap) + 8px); right: 10px; left: auto; z-index: 1100; }
    /* Zoom & north-up button sizes */
    .ol-zoom button, .ol-rotate button { width: var(--ctlSz); height: var(--ctlSz); font-size: 16px; border-radius: 8px; }
    .ol-rotate button .ol-compass { font-size: 12px; }
    html, body { height: 100%; margin: 0; }
    :root { --vh: 100vh; --tabH: calc(var(--vh) / 3); }
    @supports (height: 100dvh) { :root { --vh: 100dvh; } }
    :root { --ctlSz: 34px; --ctlGap: 4px; }
    #map { position: relative; width: 100%; height: 100%; }
    .panel {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      background: rgba(255,255,255,0.95); padding: 12px 14px; border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15); font-family: system-ui, Arial, sans-serif; min-width: 300px;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px; }
    label { font-size: 12px; color: #333; }
    select, input[type="text"], button {
      font-size: 14px; padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; outline: none;
    }
    /* Prevent mobile zoom on input focus by keeping font-size >=16px */
    @media (hover:none) and (pointer:coarse) {
      input[type="text"],
      input[type="search"],
      input[type="email"],
      input[type="tel"],
      input[type="number"],
      input[type="password"],
      textarea,
      select,
      button {
        font-size: 16px !important;
      }
    }
    button { cursor: pointer; background: #111827; color: #fff; border: none; }
    button:disabled { opacity: 0.5; cursor: default; }
    .small { font-size: 12px; color: #444; }
    .inline { display: flex; gap: 8px; align-items: center; }
    .w-100 { width: 100%; }
    .muted { color: #666; }
    .pill {
      display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 11px; background: #f3f4f6; color: #111827;
    }
    .error { color: #b91c1c; }
    .ok { color: #065f46; }
    .link { color: #2563eb; text-decoration: none; }
    .kvgrid { display: grid; grid-template-columns: max-content 1fr; gap: 6px 12px; align-items: start; }
    .kv-key { font-weight: 600; color: #334155; white-space: nowrap; }
    .kv-val { color: #111827; overflow-wrap: anywhere; }
    .badge { display:inline-block; padding:1px 6px; border-radius:999px; background:#eef2ff; color:#3730a3; font-size:11px; }
    .bottombar {
      position: absolute; left: 0; right: 0; bottom: 0; z-index: 1000;
      background: rgba(255,255,255,0.95); border-radius: 12px 12px 0 0; padding: 4px 6px calc(4px + env(safe-area-inset-bottom, 0px));
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
      /* stack: tabs (fixed) + active panel (scroll) + credits (fixed) */
      display: flex; flex-direction: column; gap: 6px; align-items: stretch;
      height: var(--barH, var(--tabH, 160px)); max-height: 90vh; min-height: var(--barMin, 110px); overflow: hidden; box-sizing: border-box;
      /* Force compositing/painting on mobile Safari to avoid transparent-on-load bug */
      background-color: rgba(255,255,255,0.97); /* explicit color layer */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      backface-visibility: hidden;
      will-change: transform;
      isolation: isolate; /* new stacking context above map */
      -webkit-overflow-scrolling: touch; /* smooth panel scroll on iOS */
    }
    /* collapse/expand bottom bar — keep tabs visible for reopen */
    .bottombar.collapsed {
      height: auto;
      min-height: 0;
      padding-top: 2px;
      padding-bottom: calc(2px + env(safe-area-inset-bottom, 0px));
    }
    .bottombar.collapsed .bar-resizer,
    .bottombar.collapsed .section-sep,
    .bottombar.collapsed .tab-panel,
    .bottombar.collapsed .creditbar { display: none !important; }
    /* ensure tabs remain visible and clickable when collapsed */
    .bottombar.collapsed .tabs { display: flex !important; }
    .creditbar { display:flex; align-items:center; gap:8px; }
    /* drag handle to resize bottom bar */
    .bar-resizer { flex: 0 0 auto; height: 16px; cursor: ns-resize; display: flex; align-items: center; justify-content: center; touch-action: none; }
    .bar-resizer .grip { width: 56px; height: 5px; border-radius: 999px; background: #d1d5db; }
    .bar-resizer:hover .grip { background: #9ca3af; }
    .bottombar .lbl { font-size: 12px; color: #333; margin-right: 6px; }
    .bottombar .spacer { flex: 1; }
    /* Bigger action buttons */
    .btn-lg { font-size: 15px; padding: 10px 16px; border-radius: 10px; }
    .btn-green { background:#10b981; }
    .btn-green:hover { background:#059669; }
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 2000; }
    .modal.show { display: flex; }
    .modal .content { background: #fff; max-width: 720px; width: min(720px, 92vw); max-height: 80vh; overflow: auto; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); padding: 16px 18px; }
    .modal .hd { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .modal .close { background: transparent; border: none; font-size: 20px; line-height: 1; cursor: pointer; padding: 6px; }

    /* Loading spinner */
    .loader {
      border: 3px solid #f3f4f6; /* tailwind gray-100 */
      border-top: 3px solid #3b82f6; /* tailwind blue-500 */
      border-radius: 50%;
      width: 18px;
      height: 18px;
      animation: spin 1s linear infinite;
      display: none; /* Hidden by default */
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* split guides + spyglass */
    .divider-v { position:absolute; top:0; left:0; width:0; height:0; border-left:2px dashed rgba(0,0,0,0.45); pointer-events:none; z-index:999; display:none; }
    .divider-h { position:absolute; top:0; left:0; width:0; height:0; border-top:2px dashed rgba(0,0,0,0.45); pointer-events:none; z-index:999; display:none; }
    .lens { position: absolute; pointer-events: none; border: 2px solid rgba(0,0,0,0.5); border-radius: 9999px; box-shadow: 0 0 0 2px rgba(255,255,255,0.85) inset; z-index: 999; display: none; cursor: default; }
    .lens:active { cursor: default; }

    /* drag handles */
    .handle, .lens-handle {
      position: absolute; width: 16px; height: 16px; border-radius: 9999px;
      background: #fff; border: 2px solid rgba(0,0,0,0.55); box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      z-index: 1000; display: none; pointer-events: auto;
    }
    .handle-v { cursor: ew-resize; }
    .handle-h { cursor: ns-resize; }
    .lens-handle { cursor: nwse-resize; }

    .range { width: 100%; }
    /* Tab strip: pill buttons, text-only, small and tight */
    .tabs { display:flex; align-items:center; gap:6px; padding:2px; margin-bottom:4px; }
    .tab-btn {
      position: relative;
      display: inline-flex; align-items: center; gap: 0;
      appearance: none; cursor: pointer;
      font-size: 13px; font-weight: 600; color: #111827;
      padding: 6px 10px; border-radius: 12px;
      border: 1px solid #e5e7eb;
      background: linear-gradient(#ffffff, #f8fafc);
      box-shadow: 0 1px 0 rgba(0,0,0,0.03), inset 0 -1px 0 rgba(0,0,0,0.02);
      transition: background .15s ease, box-shadow .15s ease, border-color .15s ease, color .15s ease;
    }
    .tab-btn:hover { background: #f3f4f6; border-color:#d1d5db; }
    .tab-btn:active { transform: translateY(0.5px); }
    .tab-btn.active { background:#111827; color:#fff; border-color:#111827; box-shadow: 0 2px 6px rgba(0,0,0,0.12) inset; }
    /* labeled separator under tabs */
    .section-sep { display:flex; align-items:center; gap:10px; margin:4px 0 8px; }
    .section-sep::before, .section-sep::after { content:""; flex:1; height:2px; background: linear-gradient(to right, transparent, #cbd5e1, transparent); }
    .section-sep span { font-size:12px; font-weight:600; color:#111827; background: rgba(255,255,255,0.95); border:1px solid #e5e7eb; border-radius:999px; padding:3px 10px; }

    /* Simplify the tab separator: no label, single line */
    .section-sep { display:block; height:1px; background:#cbd5e1; margin:6px 0 8px; }
    .section-sep::before, .section-sep::after { content:none; }
    .section-sep span { display:none; }

    /* Sticky actions for More tab */
    #panelMore .sticky-actions { position: sticky; top: 0; z-index: 5; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; padding:8px 0; background: rgba(255,255,255,0.95); border-bottom:1px solid #e5e7eb; backdrop-filter: blur(2px); }
    /* Pretty pill buttons */
    .btn-chip { appearance:none; display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:9999px; border:1px solid #d1d5db; background: linear-gradient(#ffffff, #f8fafc); color:#111827; text-decoration:none; font-size:13px; font-weight:600; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }
    .btn-chip:hover { background:#f3f4f6; border-color:#cbd5e1; }
    .btn-chip:active { transform: translateY(1px); }

    /* colored action buttons */
    .btn-blue  { background:#2563eb; color:#fff; }
    .btn-blue:hover  { background:#1d4ed8; }
    .btn-indigo{ background:#6366f1; color:#fff; }
    .btn-indigo:hover{ background:#4f46e5; }
    .btn-red   { background:#ef4444; color:#fff; }
    .btn-red:hover   { background:#dc2626; }
    /* Control panel 4-column grid */
    .control-grid { display:grid; grid-template-columns: max-content 1fr max-content 1fr; grid-auto-rows: min-content; gap: 12px 16px; align-items: end; }
    .control-grid .inline { min-width: 0; }
    .control-grid .lbl { align-self: end; margin-right: 0; }
    .control-grid .span3 { grid-column: 1 / span 3; }
    .control-grid .right { justify-self: end; align-self: end; }
    @media (max-width: 1100px) {
      .control-grid { grid-template-columns: 1fr 1fr; }
      .control-grid .span3 { grid-column: 1 / -1; }
      .control-grid .right { justify-self: start; }
    }
    @media (max-width: 760px) {
      :root { --tabH: calc(var(--vh) / 3.8); }
      /* Mobile: two columns => Label | Selector */
      .control-grid { grid-template-columns: max-content 1fr; }
      /* Keep controls compact; make overlay input the same visual width as basemap */
      .control-grid #basemap,
      .control-grid #allmapsId { width: min(50vw, 200px); }
      /* Bigger resizer target on mobile */
      .bar-resizer { height: 21px; }
      .bar-resizer .grip { width: 72px; height: 6px; }
      /* Mobile: split Research toolbar into two lines */
      .toolbar { flex-wrap: wrap; justify-content: center; }
      .toolbar .break { display:block; flex-basis:100%; height:0; }
    }
    .tab-panel { display:none; width:100%; gap:10px; align-items:stretch; flex-direction:column; flex:1 1 auto; min-height:0; overflow:auto; }
    .tab-panel.active { display:flex; }
    /* tool buttons (single active) */
    .tool-btn { appearance:none; border:1px solid #d1d5db; background:#f8fafc; color:#111827; padding:6px 10px; border-radius:8px; font-size:13px; cursor:pointer; }
    .tool-btn.active { background:#111827; color:#fff; border-color:#111827; }

    /* Toolbar: desktop = single line (centered); mobile = two lines */
    .toolbar { display:flex; gap:14px; align-items:center; justify-content:center; flex-wrap:nowrap; }
    .toolbar .break { display:none; }

    /* annotation table */
    .tbl { width: 100%; border-collapse: collapse; }
    .tbl th, .tbl td { border: 1px solid #e5e7eb; padding: 6px 8px; font-size: 12px; }
    .tbl th { background: #f8fafc; text-align: left; font-weight: 600; }
    .tbl input[type="text"] { width: 100%; padding: 4px 6px; font-size: 12px; border: 1px solid #d1d5db; border-radius: 6px; }

    /* Annotation table action buttons */
    .tbl td .anno-zoom,
    .tbl td .anno-del {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 6px;
      border: none;
      min-width: 0;
      background: none;
      box-shadow: none;
      line-height: 1.2;
      transition: background 0.14s;
    }
    .tbl td .anno-zoom {
      background-color: #111827;
      color: #fff;
    }
    .tbl td .anno-zoom:hover,
    .tbl td .anno-zoom:focus {
      background-color: #374151;
      color: #fff;
    }
    .tbl td .anno-del {
      background-color: #dc2626;
      color: #fff;
    }
    .tbl td .anno-del:hover,
    .tbl td .anno-del:focus {
      background-color: #b91c1c;
      color: #fff;
    }
    /* annotation list scroll container */
    .anno-wrap { width: 100%; margin-top: 8px; flex:1 1 auto; min-height:0; overflow:auto; }
    /* keep table header visible while scrolling */
    .tbl thead th { position: sticky; top: 0; background: #f8fafc; z-index: 1; }

    /* search panel */
    .results-wrap { width: 100%; margin-top: 8px; flex:1 1 auto; min-height:0; overflow:auto; }
    .results { display: grid; gap: 6px; }
    .result-item { border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px 10px; cursor: pointer; background:#fff; }
    .result-item:hover { background: #f8fafc; }
    .result-title { font-size: 13px; color:#111827; font-weight:600; }
    .result-sub { font-size: 12px; color:#4b5563; }
    /* cleaner two-column layout for search results */
    .result-item { display: flex; gap: 12px; align-items: center; }
    .result-item .col-left { flex: 1; min-width: 0; }
    .result-item .col-right { flex: 0 0 auto; display: flex; align-items: center; gap: 8px; }
    .btnAddSearch { padding: 6px 10px; font-size: 12px; border-radius: 8px; }

    /* Results fill the panel; panel scrolls within --tabH */
    #searchResults { max-height: none; overflow: visible; }
    #searchResults .result-item { padding: 8px 0; border-bottom: 1px solid #e5e7eb; }
    /* credit footer inside bottombar */
    .creditbar { flex: 0 0 auto; border-top: 1px solid #e5e7eb; padding-top: 6px; }
    .bottombar.collapsed .creditbar { border-top: none; padding-top: 0; }
    /* right-click coordinate popup */
    .coordmenu {
      position: absolute; z-index: 2500; display: none;
      background: #fff; border: 1px solid #e7e7eb; border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.18); padding: 10px; min-width: 220px;
    }
    .coordmenu .hd { font-weight: 600; font-size: 13px; color:#111827; margin-bottom: 6px; }
    .coordmenu .val { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; color:#111827; background:#f9fafb; border:1px solid #e7e7eb; border-radius:8px; padding:6px 8px; cursor: pointer; user-select: all; }
    .coordmenu .sub { font-size: 12px; color:#6b7280; margin-top: 6px; }
    .coordmenu .actions { display:flex; gap:8px; margin-top:8px; }
    .coordmenu button { padding: 6px 10px; font-size: 12px; border-radius: 8px; background:#111827; color:#fff; border:none; cursor:pointer; }
    
    /* ===== Compact UI overrides (safe to append at end of <style>) ===== */

    /* Slimmer bottom padding */
    .bottombar { padding: 0px 0px calc(2px + env(safe-area-inset-bottom, 0px)); }

    /* Tabs: text-only, smaller, tighter spacing */
    .tabs { display:flex; align-items:center; gap:6px; padding:0 2px; margin-bottom:2px; }
    .tab-btn { padding:6px 10px; }

    /* Separator tighter */
    .section-sep { display:block; height:1px; background:#cbd5e1; margin:4px 0 6px; }
    .section-sep::before, .section-sep::after { content:none; }
    .section-sep span { display:none; }

    /* Control panel grid: consistent label column + tighter gaps */
    @media (min-width: 761px) {
      .control-grid { display:grid; grid-template-columns: 80px 1fr 80px 1fr; grid-auto-rows: min-content; gap:8px 12px; align-items:center; }
    }
    .control-grid .lbl { align-self:center; justify-self:end; margin-right:0; color:#0f172a; font-weight:600; }

    @media (max-width: 760px) {
      .control-grid { grid-template-columns: 88px 1fr; gap:8px 10px; align-items:center; }
      .control-grid .inline { min-width: 0; }
      .control-grid select,
      .control-grid input[type="text"],
      .control-grid .w-100 { width: 100%; }
    }

    /* Inputs/select/buttons padding */
    select, input[type="text"], button { font-size:14px; padding:7px 9px; border-radius:8px; border:1px solid #ccc; outline:none; }

    /* Large buttons (Load / Metadata) */
    .btn-lg { font-size:14px; padding:8px 14px; border-radius:10px; }

    /* Slimmer slider */
    .range { width:100%; height:22px; }
    .range::-webkit-slider-runnable-track { height:6px; border-radius:999px; }
    .range::-webkit-slider-thumb { margin-top:-7px; height:20px; width:20px; border-radius:50%; }

    /* Helper text line-height for compact layout */
    .small { font-size:12px; color:#444; line-height:1.35; }
  </style>
</head>
<body>
  <div id="map">
    <img class="map-logo" src="https://raw.githubusercontent.com/lqtue/VMA/main/data/logo.png" alt="Logo" />
    <div id="dividerX" class="divider-v"></div>
    <div id="dividerY" class="divider-h"></div>
    <div id="lens" class="lens"></div>
    <div id="lensHandle" class="lens-handle" title="Resize lens"></div>
    <div id="dividerHandleX" class="handle handle-v" title="Drag split (X)"></div>
    <div id="dividerHandleY" class="handle handle-h" title="Drag split (Y)"></div>
  </div>

  <div id="coordMenu" class="coordmenu" role="dialog" aria-label="Coordinates">
    <div class="hd">Coordinates</div>
    <div id="coordValue" class="val">—</div>
    <div class="sub">Click the value to copy.</div>
    <div class="actions">
        <button id="coordCopy">Copy</button>
        <button id="coordClose">Close</button>
    </div>
  </div>

  <div class="bottombar">
    <div id="barResizer" class="bar-resizer" role="separator" aria-orientation="vertical" title="Drag to resize">
      <div class="grip"></div>
    </div>
    <div class="tabs">
      <button id="tabControl" class="tab-btn active">Control</button>
      <button id="tabResearch" class="tab-btn">Research</button>
      <button id="tabSearch" class="tab-btn">Search</button>
      <button id="tabMore" class="tab-btn">More</button>
      <span class="spacer"></span>
    </div>
    <div id="panelDivider" class="section-sep"><span id="panelDividerLabel">Control</span></div>

    <div id="panelControl" class="tab-panel active" role="tabpanel" aria-labelledby="tabControl">
      <div class="control-grid">
        <div class="lbl">Basemap</div>
        <div class="inline">
          <select id="basemap">
            <option value="esri-imagery" selected>Esri World Imagery</option>
            <option value="g-streets">Google Streets</option>
            <option value="g-satellite">Google Satellite</option>
          </select>
        </div>
        <div class="lbl">View</div>
        <div class="inline">
          <select id="viewMode">
            <option value="overlay" selected>Overlay</option>
            <option value="side-x">Side-by-side X</option>
            <option value="side-y">Side-by-side Y</option>
            <option value="spy">Spyglass</option>
          </select>
        </div>

        <div class="lbl">Overlay</div>
        <div class="inline">
          <select id="allmapsId" class="w-100"></select>
        </div>
        <div class="lbl">Opacity</div>
        <div class="inline">
          <input id="opacityRange" class="range" type="range" min="0" max="1" step="0.01" value="0.80" />
          <span id="opLabel" class="small muted">80%</span>
        </div>

        <div class="lbl">Custom ID</div>
        <div class="inline" style="grid-column: 2 / -1;">
          <input class="w-100" type="text" id="customMapId" placeholder="Or enter a custom Allmaps ID..." />
          <button id="loadCustomBtn" class="btn-green" style="flex-shrink: 0;">Load</button>
        </div>
      </div>
      <div class="inline" style="gap:12px; align-items:center; justify-content:center;">
        <button id="metaBtn" class="btn-lg" title="Show metadata" disabled>Metadata</button>
      </div>
      <div class="inline" style="justify-content: center; align-items: center; gap: 8px; min-height: 20px; margin-top: 4px;">
        <div id="loader" class="loader"></div>
        <div id="status" class="small muted" aria-live="polite"></div>
      </div>
    </div>

    <div id="panelResearch" class="tab-panel" role="tabpanel" aria-labelledby="tabResearch">
      <div class="toolbar">
        <button id="btnPoint" type="button" class="tool-btn">Point</button>
        <button id="btnLine" type="button" class="tool-btn">Line</button>
        <button id="btnPoly" type="button" class="tool-btn">Object</button>
        <span class="break"></span>
        <button id="importCsvBtn" type="button" class="btn-green">Load</button>
        <input id="importCsvInput" type="file" accept=".csv,text/csv" style="display:none;" />
        <button id="exportCsv" type="button" disabled>Save</button>
        <button id="researchClear" class="btn-red">Clear</button>
      </div>
      <div class="small muted" style="margin-top:6px;">Tip: In <b>Line</b> and <b>Object</b> modes, press <b>Enter</b> or click on the last point to finish drawing.</div>
      <div class="anno-wrap">
        <table id="annoTable" class="tbl">
          <thead>
            <tr><th>#</th><th>Type</th><th>Label</th><th>Metric</th><th>Actions</th></tr>
          </thead>
          <tbody id="annoTbody"></tbody>
        </table>
      </div>
    </div>

    <div id="panelSearch" class="tab-panel" role="tabpanel" aria-labelledby="tabSearch">
      <div class="inline" style="gap:10px; align-items: center; width:100%;">
        <span class="lbl">Place</span>
        <input id="searchQuery" type="text" class="w-100" placeholder="e.g., Ho Chi Minh City, Notre-Dame Cathedral" />
        <button id="searchClear" type="button" class="btn-red">Clear</button>
        <button id="searchLocate" type="button" class="btn-green" title="Find my location">My location</button>
      </div>
      <div class="results-wrap">
        <div id="searchResults" class="results"></div>
      </div>
    </div>
    
    <div id="panelMore" class="tab-panel" role="tabpanel" aria-labelledby="tabMore">
      <div class="sticky-actions">
        <a class="btn-chip" href="https://example.com/about" target="_blank" rel="noreferrer">About Us</a>
        <a class="btn-chip" href="https://example.com/blog" target="_blank" rel="noreferrer">Blog</a>
        <a class="btn-chip" href="https://example.com/contact" target="_blank" rel="noreferrer">Get in touch</a>
      </div>
      <div class="small" style="margin-top:10px;">
        <div style="font-weight:600; margin-bottom:6px;">Tips & Shortcuts</div>
        <ul style="margin:0; padding-left: 18px; display:grid; gap:6px;">
          <li><b>Rotate map:</b> hold <b>Ctrl</b> (Windows/Linux) or <b>⌘ Cmd</b> (macOS) and drag. On touchpads, use a two‑finger rotate gesture. Click the rotate control to reset north‑up. Rotation is disabled in side and spyglass mode.</li>
          <li><b>Zoom:</b> scroll the mouse wheel or double‑click to zoom in.</li>
          <li><b>View modes:</b> pick <i>Overlay / Side‑by‑side X / Side‑by‑side Y / Spyglass</i>. In side‑by‑side, drag the small circle handle to move the divider. In spyglass, drag the small knob on the right edge to resize.</li>
          <li><b>Annotations:</b> choose Point/Line/Object. Press <b>Enter</b> to finish a line/polygon, <b>Esc</b> to cancel the current sketch. Edit labels in the table; use <i>Zoom</i> or <i>Delete</i> in the Actions column. Use <i>Export CSV</i> / <i>Import CSV</i> to save/restore.</li>
          <li><b>Search:</b> type a place and press Enter. Click a result to zoom. Use the <i>Add</i> button on a result to add it to annotations (the search list clears after adding).</li>
          <li><b>Coordinates:</b> right‑click anywhere on the map to show lon,lat. Click the value or the <i>Copy</i> button to copy to clipboard.</li>
          <li><b>Opacity:</b> use the slider to adjust the overlay transparency.</li>
        </ul>
      </div>
    </div>
    <div class="creditbar small muted">
      <span>© The Vietnam Map Archive Project · OpenStreetMap contributors · Allmaps · Built with OpenLayers</span>
      <span class="spacer"></span>
    </div>
  </div>

  <div id="metaModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="metaTitle">
    <div class="content">
      <div class="hd">
        <h3 id="metaTitle" style="margin:0;">Map metadata</h3>
        <button id="closeMeta" class="close" aria-label="Close">×</button>
      </div>
      <div id="metaSummary" class="small">–</div>
      <div class="small" style="margin-top:10px;">Footprint source: <span id="metaLinkWrap" class="muted">–</span></div>
      <div class="small muted" style="margin-top:10px;">Attribution: © <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank" rel="noreferrer">OpenStreetMap</a> contributors · Allmaps. Google tiles usage may require permission and a proper API.</div>
    </div>
  </div>

  <script>
    // --- State variables ---
    let currentMapId = null; // Holds the ID of the currently loaded Allmaps map
    let draw = null, keyDownFinish = null, keyDownCancel = null, fidCounter = 1;

    // --- Base layers ---
    const esriImageryLayer = new ol.layer.Tile({
      source: new ol.source.XYZ({
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        attributions: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer">Esri</a>',
        crossOrigin: 'anonymous'
      }),
      visible: true,
      properties: { 'name': 'esri-imagery', 'base': true },
      zIndex: 0
    });

    const googleStreets = new ol.layer.Tile({
      source: new ol.source.XYZ({
        urls: [
          'https://mt0.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
          'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
          'https://mt2.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
          'https://mt3.google.com/vt/lyrs=m&x={x}&y={y}&z={z}'
        ],
        maxZoom: 22,
        crossOrigin: 'anonymous',
        attributions: '© Google'
      }),
      visible: false,
      properties: { 'name': 'g-streets', 'base': true },
      zIndex: 0
    });

    const googleSatellite = new ol.layer.Tile({
      source: new ol.source.XYZ({
        urls: [
          'https://mt0.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          'https://mt2.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          'https://mt3.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'
        ],
        maxZoom: 22,
        crossOrigin: 'anonymous',
        attributions: '© Google'
      }),
      visible: false,
      properties: { 'name': 'g-satellite', 'base': true },
      zIndex: 0
    });

    // Initialize the Allmaps WarpedMapLayer
    const warpedMapLayer = new Allmaps.WarpedMapLayer({
      zIndex: 10,
      properties: { 'name': 'allmaps-overlay' }
    });

    // Optional: footprint outline layer (vector)
    const footprintSource = new ol.source.Vector();
    const footprintLayer = new ol.layer.Vector({
      source: footprintSource,
      style: new ol.style.Style({
        stroke: new ol.style.Stroke({ color: '#ef4444', width: 2 }),
        fill: new ol.style.Fill({ color: 'rgba(239,68,68,0.08)' })
      }),
      visible: false,
      zIndex: 15,
      properties: { 'name': 'footprint' }
    });

    // Research annotations layer (points/lines/polygons) with labels
    const researchSource = new ol.source.Vector();
    const researchLayer = new ol.layer.VectorImage({
      source: researchSource,
      zIndex: 20,
      imageRatio: 2,
      style: (() => {
        const stroke = new ol.style.Stroke({ color: '#2563eb', width: 2 });
        const fill   = new ol.style.Fill({ color: 'rgba(37,99,235,0.15)' });
        const pointBase = new ol.style.Style({
          image: new ol.style.Circle({
            radius: 5,
            fill: new ol.style.Fill({ color: '#2563eb' }),
            stroke: new ol.style.Stroke({ color: '#ffffff', width: 2 })
          })
        });
        const lineBase = new ol.style.Style({ stroke });
        const polyBase = new ol.style.Style({ stroke, fill });
        const cache = new Map(); // key = `${type}|${label}`

        function labelStyle(text, poly) {
          return new ol.style.Style({
            geometry: poly ? (f) => f.getGeometry().getInteriorPoint() : undefined,
            text: new ol.style.Text({
              text,
              font: '12px system-ui, Arial',
              fill: new ol.style.Fill({ color: '#111827' }),
              stroke: new ol.style.Stroke({ color: 'rgba(255,255,255,0.9)', width: 3 }),
              offsetY: poly ? 0 : -12,
              overflow: true
            })
          });
        }

        return (feature) => {
          const type  = feature.getGeometry().getType();
          const label = feature.get('label') || '';
          if (!label) {
            if (type === 'Point') return [pointBase];
            if (type.includes('Line')) return [lineBase];
            return [polyBase];
          }
          const key = `${type}|${label}`;
          let styles = cache.get(key);
          if (!styles) {
            if (type === 'Point') styles = [pointBase, labelStyle(label, false)];
            else if (type.includes('Line')) styles = [lineBase];
            else styles = [polyBase, labelStyle(label, true)];
            cache.set(key, styles);
          }
          return styles;
        };
      })(),
      properties: { 'name': 'research' }
    });

    // Search highlight layer
    const searchSource = new ol.source.Vector();
    const searchLayer = new ol.layer.VectorImage({
      source: searchSource,
      zIndex: 25,
      imageRatio: 2,
      style: new ol.style.Style({
        image: new ol.style.Circle({ radius: 6, fill: new ol.style.Fill({ color: '#f59e0b' }), stroke: new ol.style.Stroke({ color: '#fff', width: 2 }) }),
        stroke: new ol.style.Stroke({ color: '#f59e0b', width: 2, lineDash: [6,4] }),
        fill: new ol.style.Fill({ color: 'rgba(245,158,11,0.12)' })
      }),
      properties: { 'name': 'search' }
    });

    // Map
    const map = new ol.Map({
      target: 'map',
      layers: [esriImageryLayer, googleStreets, googleSatellite, warpedMapLayer, footprintLayer, researchLayer, searchLayer],
      view: new ol.View({
        center: ol.proj.fromLonLat([106.70098, 10.77653]),
        zoom: 12,
        enableRotation: true,
        constrainRotation: false
      })
    });

    // Add ScaleLine control explicitly (Attribution is included by default)
    map.addControl(new ol.control.ScaleLine());
    // Add a visible rotate control and rotation interactions
    const rotateCtrl = new ol.control.Rotate({ autoHide: false });
    map.addControl(rotateCtrl);
    const dragRotate  = new ol.interaction.DragRotate({ condition: ol.events.condition.platformModifierKeyOnly });
    const pinchRotate = new ol.interaction.PinchRotate();
    map.addInteraction(dragRotate);
    map.addInteraction(pinchRotate);

    let rotationLocked = false;
    function hasInteraction(i){ return map.getInteractions().getArray().includes(i); }
    function enableRotateInteractions(on){
      if (on) {
        if (!hasInteraction(dragRotate))  map.addInteraction(dragRotate);
        if (!hasInteraction(pinchRotate)) map.addInteraction(pinchRotate);
      } else {
        if (hasInteraction(dragRotate))  map.removeInteraction(dragRotate);
        if (hasInteraction(pinchRotate)) map.removeInteraction(pinchRotate);
      }
    }
    function lockRotation(lock){
      rotationLocked = !!lock;
      const v = map.getView();
      if (rotationLocked) {
        try { v.setRotation(0); } catch(_) {}
        enableRotateInteractions(false);
        if (rotateCtrl && rotateCtrl.element) rotateCtrl.element.style.display = 'none';
      } else {
        enableRotateInteractions(true);
        if (rotateCtrl && rotateCtrl.element) rotateCtrl.element.style.display = '';
      }
    }

    // UI elements
    const mapEl = document.getElementById('map');
    const basemapSel = document.getElementById('basemap');
    const mapSelector = document.getElementById('allmapsId');
    const statusEl = document.getElementById('status');
    const metaLinkWrap = document.getElementById('metaLinkWrap');
    const metaSummary = document.getElementById('metaSummary');
    const metaBtn = document.getElementById('metaBtn');
    const metaModal = document.getElementById('metaModal');
    const closeMeta = document.getElementById('closeMeta');
    const tabControl = document.getElementById('tabControl');
    const tabResearch = document.getElementById('tabResearch');
    const tabSearch = document.getElementById('tabSearch');
    const tabMore = document.getElementById('tabMore');
    const panelControl = document.getElementById('panelControl');
    const panelResearch = document.getElementById('panelResearch');
    const panelSearch = document.getElementById('panelSearch');
    const panelMore = document.getElementById('panelMore');
    const btnPoint = document.getElementById('btnPoint');
    const btnLine  = document.getElementById('btnLine');
    const btnPoly  = document.getElementById('btnPoly');
    const researchClear = document.getElementById('researchClear');
    const annoTbody = document.getElementById('annoTbody');
    const exportCsvBtn = document.getElementById('exportCsv');
    const importCsvBtn = document.getElementById('importCsvBtn');
    const importCsvInput = document.getElementById('importCsvInput');
    const dividerLabel = document.getElementById('panelDividerLabel');
    const searchQuery = document.getElementById('searchQuery');
    const searchClearBtn = document.getElementById('searchClear');
    const searchResults = document.getElementById('searchResults');
    const searchLocate = document.getElementById('searchLocate');
    const viewModeSel = document.getElementById('viewMode');
    const opacityRange = document.getElementById('opacityRange');
    const opLabel = document.getElementById('opLabel');
    const dividerXEl = document.getElementById('dividerX');
    const dividerYEl = document.getElementById('dividerY');
    const dividerHandleX = document.getElementById('dividerHandleX');
    const dividerHandleY = document.getElementById('dividerHandleY');
    const lensEl = document.getElementById('lens');
    const lensHandle = document.getElementById('lensHandle');
    const loader = document.getElementById('loader');
    const customMapIdInput = document.getElementById('customMapId');
    const loadCustomBtn = document.getElementById('loadCustomBtn');
    const coordMenu  = document.getElementById('coordMenu');
    const coordValue = document.getElementById('coordValue');
    const coordCopy  = document.getElementById('coordCopy');
    const coordClose = document.getElementById('coordClose');

    // --- Bottom bar resizer ---
    (function(){
      const bar = document.querySelector('.bottombar');
      const grip = document.getElementById('barResizer');
      if (!bar || !grip) return;
      const MIN_H = 200;
      function clamp2(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function apply(h){ bar.style.height = h + 'px'; }
      const saved = Number(localStorage.getItem('barH') || '');
      if (!Number.isNaN(saved) && saved > 0) {
        const vh = window.innerHeight || document.documentElement.clientHeight || saved;
        apply(clamp2(saved, MIN_H, Math.round(vh * 0.9)));
      }
      let draggingBar = false;
      grip.addEventListener('pointerdown', (e) => {
        draggingBar = true; grip.setPointerCapture(e.pointerId); e.preventDefault();
      });
      window.addEventListener('pointermove', (e) => {
        if (!draggingBar) return;
        const vh = window.innerHeight || document.documentElement.clientHeight;
        const newH = clamp2(vh - e.clientY, MIN_H, Math.round(vh * 0.9));
        apply(newH);
      });
      function stopBarDrag(){
        if (!draggingBar) return;
        draggingBar = false;
        const h = Math.round(bar.getBoundingClientRect().height);
        localStorage.setItem('barH', String(h));
      }
      window.addEventListener('pointerup', stopBarDrag);
      window.addEventListener('pointercancel', () => { draggingBar = false; });
      grip.addEventListener('dblclick', () => { bar.style.height = ''; localStorage.removeItem('barH'); });
    })();

    // --- Collapse / Expand bottom bar (keep credit visible) ---
    (function(){
      const bar = document.querySelector('.bottombar');
      if (!bar) return;
      function expandToSaved(){
        const saved = Number(localStorage.getItem('barH') || '');
        if (!Number.isNaN(saved) && saved > 0) {
          const vh = window.innerHeight || document.documentElement.clientHeight || saved;
          const clamped = Math.max(80, Math.min(saved, Math.round(vh * 0.9)));
          bar.style.height = clamped + 'px';
        } else {
          bar.style.height = '';
        }
      }
      function collapseBar(){
        try {
          const h = Math.round(bar.getBoundingClientRect().height);
          if (h > 0) localStorage.setItem('barH', String(h));
        } catch(_){}
        bar.classList.add('collapsed');
        bar.style.height = '';
        localStorage.setItem('barCollapsed','1');
      }
      function expandBar(){
        bar.classList.remove('collapsed');
        expandToSaved();
        localStorage.removeItem('barCollapsed');
      }
      // Start collapsed by default
      collapseBar();

      // On pageshow (e.g., from bfcache), respect the last state
      window.addEventListener('pageshow', () => {
        if (localStorage.getItem('barCollapsed') === '1') {
          bar.classList.add('collapsed');
          bar.style.height = '';
        } else {
          bar.classList.remove('collapsed');
          expandToSaved();
        }
      });
      window.__collapseBar = collapseBar;
      window.__expandBar = expandBar;
      window.__isBarCollapsed = () => bar.classList.contains('collapsed');
    })();

    // Basemap switching
    function setBasemap(name) {
      [esriImageryLayer, googleStreets, googleSatellite].forEach(l => l.setVisible(false));
      if (name === 'esri-imagery') esriImageryLayer.setVisible(true);
      else if (name === 'g-streets') googleStreets.setVisible(true);
      else if (name === 'g-satellite') googleSatellite.setVisible(true);
    }
    basemapSel.addEventListener('change', () => setBasemap(basemapSel.value));

    // Modal open/close handlers
    function openMeta() { if (metaBtn.disabled) return; metaModal.classList.add('show'); }
    function closeMetaFn() { metaModal.classList.remove('show'); }
    if (metaBtn) metaBtn.addEventListener('click', openMeta);
    if (closeMeta) closeMeta.addEventListener('click', closeMetaFn);
    if (metaModal) metaModal.addEventListener('click', (e) => { if (e.target === metaModal) closeMetaFn(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeMetaFn(); });

    // Tabs behavior
    let lastTabClicked = null;
    function setDivider(text){ if (dividerLabel) dividerLabel.textContent = text; }
    function showTab(panelToShow, tabToShow, label) {
        [panelControl, panelResearch, panelSearch, panelMore].forEach(p => p.classList.remove('active'));
        [tabControl, tabResearch, tabSearch, tabMore].forEach(t => t.classList.remove('active'));
        if (panelToShow) panelToShow.classList.add('active');
        if (tabToShow) tabToShow.classList.add('active');
        if (typeof setActiveTool === 'function') setActiveTool('none');
        setDivider(label);
    }
    function handleTabClick(tabName, showFn) {
      return function(e) {
        const bar = document.querySelector('.bottombar');
        if (!bar) return;
        if (bar.classList.contains('collapsed')) {
          if (window.__expandBar) window.__expandBar();
          showFn();
          lastTabClicked = tabName;
          return;
        }
        if (lastTabClicked === tabName) {
            bar.classList.contains('collapsed') ? window.__expandBar() : window.__collapseBar();
            lastTabClicked = null;
            return;
        }
        showFn();
        lastTabClicked = tabName;
      };
    }
    tabControl.addEventListener('click', handleTabClick('control', () => showTab(panelControl, tabControl, 'Control')));
    tabResearch.addEventListener('click', handleTabClick('research', () => showTab(panelResearch, tabResearch, 'Research')));
    tabSearch.addEventListener('click', handleTabClick('search', () => showTab(panelSearch, tabSearch, 'Search')));
    tabMore.addEventListener('click', handleTabClick('more', () => showTab(panelMore, tabMore, 'More')));
    showTab(panelControl, tabControl, 'Control'); // Initial state

    // Load Allmaps overlay by ID (using the Allmaps Plugin)
    async function loadAllmaps(id) {
      if (!id) return;
      currentMapId = null;
      warpedMapLayer.clear();
      footprintSource.clear();
      if (loader) loader.style.display = 'block';
      if (statusEl) {
        statusEl.textContent = 'Loading map annotation...';
        statusEl.className = 'small muted';
      }
      if (metaBtn) metaBtn.disabled = true;

      const annotationUrl = `https://annotations.allmaps.org/images/${id}`;
      if(metaLinkWrap) metaLinkWrap.innerHTML = `<a class="link" href="${annotationUrl}" target="_blank" rel="noreferrer">${annotationUrl}</a>`;

      try {
        const response = await fetch(annotationUrl);
        if (!response.ok) throw new Error(`Annotation not found (HTTP ${response.status})`);
        const annotation = await response.json();

        const mapIds = await warpedMapLayer.addGeoreferenceAnnotation(annotation);
        if (!mapIds || mapIds.length === 0 || mapIds[0] instanceof Error) {
            throw mapIds[0] || new Error('Failed to add map to layer.');
        }
        currentMapId = mapIds[0];

        const extent = warpedMapLayer.getExtent();
        if (extent && !ol.extent.isEmpty(extent)) {
            map.getView().fit(extent, { padding: [80, 20, 20, 20], duration: 500, maxZoom: 18 });
            const footprintFeature = new ol.Feature(ol.geom.Polygon.fromExtent(extent));
            footprintSource.addFeature(footprintFeature);
        }

        renderMetadataSummary(annotation, null, extent);
        if (metaBtn) metaBtn.disabled = false;
        if (statusEl) statusEl.textContent = 'Map loaded successfully.';
        
        const opacity = parseFloat(opacityRange.value);
        warpedMapLayer.setMapOpacity(currentMapId, opacity);
      } catch (err) {
        console.error(err);
        if (statusEl) {
          statusEl.textContent = `Error: ${err.message}`;
          statusEl.className = 'small error';
        }
        warpedMapLayer.clear();
        footprintSource.clear();
      } finally {
        if (loader) loader.style.display = 'none';
      }
    }
    
    // Opacity control
    opacityRange.addEventListener('input', () => {
      const v = parseFloat(opacityRange.value);
      opLabel.textContent = `${Math.round(v * 100)}%`;
      if (currentMapId) {
        warpedMapLayer.setMapOpacity(currentMapId, v);
      }
    });

    // View modes: using CSS clip-path on the plugin's canvas
    let currentMode = 'overlay';
    let sideRatio = 0.5;
    let lensRadius = 150;
    let dragging = { sideX:false, sideY:false, lensR:false };

    function mapSize() { return map.getSize() || [0,0]; }

    function updateClipPath() {
        const canvas = warpedMapLayer.getCanvas();
        if (!canvas) return;
        const [w, h] = mapSize();
        if (w === 0 || h === 0) return;

        if (currentMode === 'overlay') {
            canvas.style.clipPath = '';
        } else if (currentMode === 'side-x') {
            const x = w * sideRatio;
            canvas.style.clipPath = `polygon(${x}px 0, ${w}px 0, ${w}px ${h}px, ${x}px ${h}px)`;
        } else if (currentMode === 'side-y') {
            const y = h * sideRatio;
            canvas.style.clipPath = `polygon(0 ${y}px, ${w}px ${y}px, ${w}px ${h}px, 0 ${h}px)`;
        } else if (currentMode === 'spy') {
            const cx = w / 2;
            const cy = h / 2;
            canvas.style.clipPath = `circle(${lensRadius}px at ${cx}px ${cy}px)`;
        }
    }

    function setMode(mode) {
      stopDrag();
      currentMode = mode;
      lockRotation(mode !== 'overlay');
      const currentOpacity = parseFloat(opacityRange.value);
      if (currentMapId) {
          warpedMapLayer.setMapOpacity(currentMapId, mode === 'overlay' ? currentOpacity : 1);
      }
      updateClipPath();
      updateDividersAndHandles();
      updateLensAndHandle();
    }
    viewModeSel.addEventListener('change', () => setMode(viewModeSel.value));

    map.on('moveend', updateClipPath);
    map.on('change:size', updateClipPath);

    function onMove(e) {
      if (!Object.values(dragging).some(Boolean)) return;
      const rect = mapEl.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const [w,h] = mapSize();
      if (dragging.lensR) {
        const cx = w/2, cy = h/2;
        const dx = x - cx, dy = y - cy;
        lensRadius = Math.max(20, Math.min(Math.sqrt(dx*dx + dy*dy), Math.min(w,h)/2));
        updateLensAndHandle();
      } else if (dragging.sideX) {
        sideRatio = Math.max(0.01, Math.min(x / w, 0.99));
        updateDividersAndHandles();
      } else if (dragging.sideY) {
        sideRatio = Math.max(0.01, Math.min(y / h, 0.99));
        updateDividersAndHandles();
      }
      updateClipPath();
    }
    function stopDrag(){ dragging = { sideX:false, sideY:false, lensR:false }; }
    dividerHandleX.addEventListener('pointerdown', (e)=>{ if (currentMode!=='side-x') return; dragging.sideX=true; dividerHandleX.setPointerCapture(e.pointerId); e.preventDefault(); });
    dividerHandleY.addEventListener('pointerdown', (e)=>{ if (currentMode!=='side-y') return; dragging.sideY=true; dividerHandleY.setPointerCapture(e.pointerId); e.preventDefault(); });
    lensHandle.addEventListener('pointerdown', (e)=>{ if (currentMode!=='spy') return; dragging.lensR=true; lensHandle.setPointerCapture(e.pointerId); e.preventDefault(); });
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', stopDrag);
    window.addEventListener('pointercancel', stopDrag);

    // Functions to update the visual divider/lens UI elements
    function updateDividersAndHandles() {
        const [w, h] = mapSize();
        const cx = w / 2, cy = h / 2;
        const showX = currentMode === 'side-x', showY = currentMode === 'side-y';
        dividerXEl.style.display = showX ? 'block' : 'none';
        dividerHandleX.style.display = showX ? 'block' : 'none';
        if (showX) {
            const x = w * sideRatio;
            dividerXEl.style.left = x + 'px';
            dividerXEl.style.height = h + 'px';
            dividerHandleX.style.left = (x - 8) + 'px';
            dividerHandleX.style.top  = (cy - 8) + 'px';
        }
        dividerYEl.style.display = showY ? 'block' : 'none';
        dividerHandleY.style.display = showY ? 'block' : 'none';
        if (showY) {
            const y = h * sideRatio;
            dividerYEl.style.top = y + 'px';
            dividerYEl.style.width = w + 'px';
            dividerHandleY.style.left = (cx - 8) + 'px';
            dividerHandleY.style.top = (y - 8) + 'px';
        }
    }
    function updateLensAndHandle() {
        const [w, h] = mapSize();
        const cx = w / 2, cy = h / 2;
        const d = Math.max(20, lensRadius * 2);
        const show = currentMode === 'spy';
        lensEl.style.display = show ? 'block' : 'none';
        lensHandle.style.display = show ? 'block' : 'none';
        if (show) {
            lensEl.style.width=d+'px'; lensEl.style.height=d+'px';
            lensEl.style.left=(cx - lensRadius)+'px'; lensEl.style.top=(cy - lensRadius)+'px';
            lensHandle.style.left=(cx + lensRadius - 8)+'px';
            lensHandle.style.top =(cy - 8)+'px';
        }
    }
    setMode('overlay');
    
    // --- All remaining functions (research tools, search, CSV, metadata summary, etc.) are included below ---
    
    // Research tools
    function formatLen(m){ return (m>1000)? (m/1000).toFixed(2)+' km' : m.toFixed(1)+' m'; }
    function formatArea(a){ return (a>=1e6)? (a/1e6).toFixed(2)+' km²' : a.toFixed(1)+' m²'; }
    function getOrAssignId(feat){ if (!feat.getId()){ feat.setId('a'+(fidCounter++)); } return feat.getId(); }
    function metricForFeature(feat){
        const g = feat.getGeometry(); const t = g.getType();
        try{
            if (t==='Point'){
                const lonlat = ol.proj.toLonLat(g.getCoordinates());
                return lonlat[0].toFixed(5)+', '+lonlat[1].toFixed(5);
            } else if (t==='LineString'){
                const len = ol.sphere.getLength(g, { projection: 'EPSG:3857' });
                return formatLen(len);
            } else if (t==='Polygon'){
                const area = ol.sphere.getArea(g, { projection: 'EPSG:3857' });
                return formatArea(area);
            }
        } catch(_){ }
        return '—';
    }
    function refreshAnnoTable(){
        if (!annoTbody) return;
        const feats = researchSource.getFeatures();
        if (exportCsvBtn) exportCsvBtn.disabled = (feats.length === 0);
        let html = '';
        for (const f of feats){
            const id = getOrAssignId(f);
            const t = f.getGeometry().getType();
            const label = f.get('label') || '';
            const metric = metricForFeature(f);
            html += `<tr data-id="${id}">`
                  + `<td>${id}</td>`
                  + `<td>${t.replace('LineString','Line')}</td>`
                  + `<td><input type="text" class="anno-label" value="${label.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}" /></td>`
                  + `<td>${metric}</td>`
                  + `<td><button class="anno-zoom">Zoom</button> <button class="anno-del">Delete</button></td>`
                  + `</tr>`;
        }
        annoTbody.innerHTML = html || '<tr><td colspan="5" class="muted">No annotations yet.</td></tr>';
        annoTbody.querySelectorAll('tr[data-id]').forEach(row => {
            const id = row.getAttribute('data-id');
            const f = researchSource.getFeatureById(id);
            if (!f) return;
            const input = row.querySelector('input.anno-label');
            if (input) input.addEventListener('input', () => { f.set('label', input.value); researchLayer.changed(); });
            const btnZ = row.querySelector('button.anno-zoom');
            if (btnZ) btnZ.addEventListener('click', () => {
                const ext = f.getGeometry().getExtent();
                map.getView().fit(ext, { padding:[80,20,20,20], duration: 300, maxZoom: 18 });
            });
            const btnD = row.querySelector('button.anno-del');
            if (btnD) btnD.addEventListener('click', () => { researchSource.removeFeature(f); });
        });
    }
    function cleanupTool(){
        if (draw) { map.removeInteraction(draw); draw = null; }
        if (keyDownFinish) { document.removeEventListener('keydown', keyDownFinish); keyDownFinish = null; }
        if (keyDownCancel) { document.removeEventListener('keydown', keyDownCancel); keyDownCancel = null; }
        [btnPoint, btnLine, btnPoly].forEach(b => b && b.classList.remove('active'));
    }
    function setActiveTool(mode){
        cleanupTool();
        if (!mode || mode==='none') return;
        let type = null;
        if (mode==='point') { type='Point'; if (btnPoint) btnPoint.classList.add('active'); }
        else if (mode==='line') { type='LineString'; if (btnLine) btnLine.classList.add('active'); }
        else if (mode==='polygon') { type='Polygon'; if (btnPoly) btnPoly.classList.add('active'); }
        if (!type) return;
        draw = new ol.interaction.Draw({ source: researchSource, type, stopClick:true });
        map.addInteraction(draw);
        if (mode==='line' || mode==='polygon') {
            keyDownFinish = (e) => { if (e.key === 'Enter') { e.preventDefault(); try{ draw.finishDrawing(); }catch(_){} } };
            document.addEventListener('keydown', keyDownFinish);
            keyDownCancel = (e) => { if (e.key === 'Escape') { e.preventDefault(); try{ draw.abortDrawing(); }catch(_){} } };
            document.addEventListener('keydown', keyDownCancel);
        }
        draw.on('drawend', (e) => { getOrAssignId(e.feature); refreshAnnoTable(); });
    }
    if (btnPoint) btnPoint.addEventListener('click', () => setActiveTool(btnPoint.classList.contains('active') ? 'none' : 'point'));
    if (btnLine)  btnLine .addEventListener('click', () => setActiveTool(btnLine .classList.contains('active') ? 'none' : 'line'));
    if (btnPoly)  btnPoly .addEventListener('click', () => setActiveTool(btnPoly .classList.contains('active') ? 'none' : 'polygon'));
    researchSource.on(['addfeature', 'removefeature', 'clear'], refreshAnnoTable);
    if (researchClear) researchClear.addEventListener('click', () => { researchSource.clear(); });
    setActiveTool('none');
    refreshAnnoTable();

    // Nominatim Search
    function escHtml(s){ return String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function renderSearchItems(items){
        if (!searchResults) return;
        if (!items || !items.length){ searchResults.innerHTML = '<div class="small muted">No results.</div>'; return; }
        searchResults.innerHTML = '';
        items.forEach((it) => {
            const div = document.createElement('div');
            div.className = 'result-item';
            const title = escHtml(it.display_name || `${it.type || ''}`);
            const sub = escHtml([it.class, it.type, it.category].filter(Boolean).join(' · '));
            div.innerHTML = `<div class="col-left"><div class="result-title">${title}</div><div class="result-sub">${sub}</div></div><div class="col-right"><button type="button" class="btnAddSearch">Add</button></div>`;
            div.addEventListener('click', () => zoomToSearchResult(it));
            const addBtn = div.querySelector('.btnAddSearch');
            if (addBtn) addBtn.addEventListener('click', (ev) => { ev.stopPropagation(); addResultToAnnotations(it); });
            searchResults.appendChild(div);
        });
    }
    function createFeatureFromSearchResult(it) {
        try {
            let feat = null;
            if (it.geojson) {
                const gjFmt = new ol.format.GeoJSON();
                feat = gjFmt.readFeature({ type: 'Feature', geometry: it.geojson }, { dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857' });
            } else if (it.boundingbox) {
                const bb = it.boundingbox.map(Number);
                const extent = [bb[2], bb[0], bb[3], bb[1]];
                const ext3857 = ol.proj.transformExtent(extent, 'EPSG:4326', 'EPSG:3857');
                feat = new ol.Feature({ geometry: ol.geom.Polygon.fromExtent(ext3857) });
            } else if (it.lat && it.lon) {
                const c = ol.proj.fromLonLat([Number(it.lon), Number(it.lat)]);
                feat = new ol.Feature({ geometry: new ol.geom.Point(c) });
            }
            if (feat) {
                const lbl = it.display_name || it.name || it.type || '';
                if (lbl) feat.set('label', lbl);
            }
            return feat;
        } catch (e) { console.warn("Could not create feature from search result:", e); return null; }
    }
    function zoomToSearchResult(it) {
        searchSource.clear();
        const feat = createFeatureFromSearchResult(it);
        if (!feat) return;
        searchSource.addFeature(feat);
        const geom = feat.getGeometry();
        if (geom.getType() === 'Point') {
            map.getView().animate({ center: geom.getCoordinates(), duration: 400, zoom: Math.max(map.getView().getZoom() || 12, 16) });
        } else {
            map.getView().fit(geom.getExtent(), { padding: [80, 20, 20, 20], duration: 400, maxZoom: 18 });
        }
    }
    function addResultToAnnotations(it) {
        const feat = createFeatureFromSearchResult(it);
        if (!feat) return;
        researchSource.addFeature(feat);
        searchSource.clear();
        if (searchResults) searchResults.innerHTML = '';
        if (searchQuery) searchQuery.value = '';
    }
    let searchAbort = null, searchTimer = null, lastSearchTime = 0;
    const MIN_SEARCH_INTERVAL = 1000;
    async function runSearchNow() {
        const q = (searchQuery?.value || '').trim();
        if (!q) { if (searchResults) searchResults.innerHTML = '<div class="small muted">Enter a place or address.</div>'; return; }
        if (searchAbort) { try { searchAbort.abort(); } catch (_) { } }
        searchAbort = new AbortController();
        if (searchResults) searchResults.innerHTML = '<div class="small muted">Searching…</div>';
        try {
            const params = new URLSearchParams({ format: 'jsonv2', q, addressdetails: '1', namedetails: '1', polygon_geojson: '1', limit: '10' });
            const nominatimUrl = `https://nominatim.openstreetmap.org/search?${params}`;
            const res = await fetch(nominatimUrl, { headers: { 'Accept': 'application/json' }, signal: searchAbort.signal });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            renderSearchItems(Array.isArray(data) ? data : []);
        } catch (err) {
            if (err.name === 'AbortError') return;
            console.error('Search error:', err);
            if (searchResults) searchResults.innerHTML = '<div class="small error">Search failed. Please try again later.</div>';
        }
    }
    function queueSearch() {
        if (searchTimer) clearTimeout(searchTimer);
        const now = Date.now();
        const wait = Math.max(0, MIN_SEARCH_INTERVAL - (now - lastSearchTime));
        searchTimer = setTimeout(() => { lastSearchTime = Date.now(); runSearchNow(); }, wait + 400);
    }
    if (searchQuery) {
        searchQuery.addEventListener('input', queueSearch);
        searchQuery.addEventListener('keydown', (e) => { if (e.key === 'Enter') runSearchNow(); });
    }
    if (searchClearBtn) searchClearBtn.addEventListener('click', () => {
        if (searchAbort) { try { searchAbort.abort(); } catch (_) { } }
        if (searchResults) searchResults.innerHTML = '';
        searchSource.clear();
        if (searchQuery) searchQuery.value = '';
    });
    // Geolocation
    function locateMe() {
        if (!('geolocation' in navigator) || (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1')) {
            if (searchResults) searchResults.innerHTML = '<div class="small error">Geolocation requires a secure connection (HTTPS).</div>';
            return;
        }
        if (searchResults) searchResults.innerHTML = '<div class="small muted">Locating…</div>';
        navigator.geolocation.getCurrentPosition((pos) => {
            const { latitude: lat, longitude: lon, accuracy } = pos.coords || {};
            const center = ol.proj.fromLonLat([Number(lon), Number(lat)]);
            searchSource.clear();
            searchSource.addFeature(new ol.Feature({ geometry: new ol.geom.Point(center) }));
            if (Number.isFinite(accuracy) && accuracy > 0) {
                searchSource.addFeature(new ol.Feature({ geometry: new ol.geom.Circle(center, accuracy) }));
            }
            map.getView().animate({ center, duration: 500, zoom: Math.max(map.getView().getZoom() || 12, 16) });
            if (searchResults) searchResults.innerHTML = '<div class="small ok">Centered on your location.</div>';
        }, (err) => {
            let msg = 'Could not get your location.';
            if (err && typeof err.code === 'number') {
                if (err.code === 1) msg = 'Permission denied. Please allow location access.';
                else if (err.code === 2) msg = 'Position unavailable. Try again.';
                else if (err.code === 3) msg = 'Location request timed out. Please retry.';
            }
            if (searchResults) searchResults.innerHTML = `<div class="small error">${msg}</div>`;
        }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 });
    }
    if (searchLocate) searchLocate.addEventListener('click', locateMe);

    // CSV export / import for annotations
    const wktFormat = new ol.format.WKT();
    function csvEscape(val) {
        if (val == null) return '';
        const s = String(val);
        if (/[,"\n\r]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
        return s;
    }
    function featureToCsvRow(f) {
        const id = f.getId() || '';
        const geom = f.getGeometry();
        const type = geom.getType();
        const label = f.get('label') || '';
        const wkt = wktFormat.writeGeometry(geom); // EPSG:3857
        return [id, type, label, wkt].map(csvEscape).join(',');
    }
    function downloadCsv() {
        const header = 'id,type,label,wkt';
        const rows = researchSource.getFeatures().map(featureToCsvRow);
        const csv = [header].concat(rows).join('\r\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.download = `annotations-${ts}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    function parseCsvLine(line) {
        const out = []; let cur = ''; let i = 0; const n = line.length; let inQ = false;
        while (i < n) {
            const ch = line[i++];
            if (inQ) {
                if (ch === '"') {
                    if (i < n && line[i] === '"') { cur += '"'; i++; } else { inQ = false; }
                } else { cur += ch; }
            } else {
                if (ch === ',') { out.push(cur); cur = ''; }
                else if (ch === '"') { inQ = true; }
                else { cur += ch; }
            }
        }
        out.push(cur);
        return out;
    }
    function importCsv(text) {
        const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
        if (!lines.length) return 0;
        let start = 0;
        const head = parseCsvLine(lines[0]).map(h => h.trim().toLowerCase());
        if (head.join(',') === 'id,type,label,wkt') start = 1;
        let count = 0;
        for (let i = start; i < lines.length; i++) {
            const cols = parseCsvLine(lines[i]);
            if (cols.length < 4) continue;
            const [idRaw, type, label, wkt] = cols;
            let geom;
            try { geom = wktFormat.readGeometry(wkt); } catch (_) { continue; }
            const feat = new ol.Feature({ geometry: geom });
            if (label) feat.set('label', label);
            let id = idRaw && idRaw.trim() ? idRaw.trim() : null;
            if (id && researchSource.getFeatureById(id)) {
                let k = 1; let nid = id + '-' + k;
                while (researchSource.getFeatureById(nid)) { k++; nid = id + '-' + k; }
                id = nid;
            }
            if (id) feat.setId(id); else getOrAssignId(feat);
            researchSource.addFeature(feat);
            count++;
        }
        return count;
    }
    if (exportCsvBtn) exportCsvBtn.addEventListener('click', downloadCsv);
    if (importCsvBtn && importCsvInput) {
        importCsvBtn.addEventListener('click', () => importCsvInput.click());
        importCsvInput.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                const text = String(reader.result || '');
                importCsv(text);
                importCsvInput.value = '';
            };
            reader.readAsText(file);
        });
    }

    // Right-click coordinates popup
    function hideCoordMenu(){ if (coordMenu){ coordMenu.style.display='none'; } }
    function openCoordMenu(lon, lat, clientX, clientY){
        if (!coordMenu) return;
        coordValue.textContent = `${lon.toFixed(6)}, ${lat.toFixed(6)}`;
        coordMenu.style.display = 'block';
        const pad = 8;
        const vw = window.innerWidth || document.documentElement.clientWidth;
        const vh = window.innerHeight || document.documentElement.clientHeight;
        const rect = coordMenu.getBoundingClientRect();
        let left = clientX + 4;
        let top  = clientY + 4;
        if (left + rect.width + pad > vw) left = Math.max(pad, vw - rect.width - pad);
        if (top  + rect.height + pad > vh) top  = Math.max(pad, clientY - rect.height - 4);
        coordMenu.style.left = Math.max(pad, left) + 'px';
        coordMenu.style.top  = Math.max(pad, top)  + 'px';
    }
    if (map && typeof map.getViewport === 'function') {
        map.getViewport().addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const pixel = map.getEventPixel(e);
            const coord = map.getCoordinateFromPixel(pixel);
            if (!coord) return;
            const [lon, lat] = ol.proj.toLonLat(coord, 'EPSG:3857');
            openCoordMenu(lon, lat, e.clientX, e.clientY);
        });
    }
    async function copyText(txt){
        try {
            await navigator.clipboard.writeText(txt);
            return true;
        } catch(_) {}
        const t = document.createElement('textarea');
        t.value = txt; t.style.position='fixed'; t.style.left='-9999px';
        document.body.appendChild(t); t.select();
        let ok = false;
        try { ok = document.execCommand('copy'); } catch(_){}
        document.body.removeChild(t);
        return ok;
    }
    async function doCopy(el, val){
        if (!val || val === '—') return;
        const ok = await copyText(val);
        const old = el.textContent;
        el.textContent = ok ? 'Copied!' : 'Failed';
        setTimeout(() => el.textContent = old, 900);
    }
    if (coordCopy) coordCopy.addEventListener('click', () => doCopy(coordCopy, coordValue.textContent));
    if (coordValue) coordValue.addEventListener('click', () => doCopy(coordValue, coordValue.textContent));
    if (coordClose) coordClose.addEventListener('click', hideCoordMenu);
    document.addEventListener('pointerdown', (e) => {
        if (coordMenu && coordMenu.style.display==='block' && !coordMenu.contains(e.target)) {
            hideCoordMenu();
        }
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideCoordMenu(); });

    // Metadata summary renderer
    const esc = (s) => String(s==null?'':s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    const fmtNum = (n) => (typeof n === 'number' ? n.toLocaleString() : n);
    const fmtArea = (a) => {
      if (typeof a !== 'number') return a;
      if (a >= 1_000_000) return `${(a/1_000_000).toLocaleString(undefined,{maximumFractionDigits:2})} km²`;
      return `${a.toLocaleString(undefined,{maximumFractionDigits:0})} m²`;
    };
    const fmtDate = (d) => { try { return new Date(d).toLocaleString(); } catch { return d; } };
    const short = (s, len=48) => {
      if (!s) return s;
      const str = String(s);
      return str.length > len ? esc(str.slice(0, len-1)) + '…' : esc(str);
    };
    function extractLabel(obj) {
      if (!obj) return undefined;
      const lbl = obj?.label;
      if (typeof lbl === 'string') return lbl;
      if (lbl && typeof lbl === 'object') {
        if (Array.isArray(lbl.none) && lbl.none[0]) return lbl.none[0];
        if (Array.isArray(lbl.en) && lbl.en[0]) return lbl.en[0];
      }
      const part = obj?.partOf;
      if (Array.isArray(part) && part[0]) return extractLabel(part[0]) || extractLabel(part[0]?.partOf?.[0]);
      return undefined;
    }
    function buildSummaryHTML(props, feature, extent4326) {
        if (!props) return '–';
        const rows = [];
        const title = extractLabel(props.resource) || extractLabel(props) || undefined;
        if (title) rows.push(['Title', title]);
        if (props.type) rows.push(['Type', props.type]);
        if (props.created) rows.push(['Created', fmtDate(props.created)]);
        if (props.modified) rows.push(['Modified', fmtDate(props.modified)]);
        const res = props.resource || {};
        if (res.id) rows.push(['Resource', `<a class="link" href="${esc(res.id)}" target="_blank" rel="noreferrer">${short(res.id)}</a>`]);
        if (typeof res.width === 'number' || typeof res.height === 'number') {
            rows.push(['Dimensions', `${fmtNum(res.width)} × ${fmtNum(res.height)} px`]);
        }
        const canvas = Array.isArray(res.partOf) && res.partOf[0] ? res.partOf[0] : undefined;
        if (canvas?.id) rows.push(['Canvas', `<a class="link" href="${esc(canvas.id)}" target="_blank" rel="noreferrer">${short(canvas.id)}</a>`]);
        const manifest = canvas?.partOf && Array.isArray(canvas.partOf) ? canvas.partOf[0] : undefined;
        if (manifest?.id) rows.push(['Manifest', `<a class="link" href="${esc(manifest.id)}" target="_blank" rel="noreferrer">${short(manifest.id)}</a>`]);
        const tr = props.transformation;
        if (tr?.type) {
            const order = tr?.options?.order != null ? ` (order ${tr.options.order})` : '';
            rows.push(['Transformation', `${esc(tr.type)}${order}`]);
        }
        const gcpCount = Array.isArray(props.gcps) ? props.gcps.length : undefined;
        if (gcpCount != null) rows.push(['GCPs', `${fmtNum(gcpCount)}`]);
        if (extent4326) {
            const [minX, minY, maxX, maxY] = extent4326;
            rows.push(['Extent (lon/lat)', `${minX.toFixed(4)}, ${minY.toFixed(4)} → ${maxX.toFixed(4)}, ${maxY.toFixed(4)}`]);
            rows.push(['Center', `${((minX + maxX) / 2).toFixed(5)}, ${((minY + maxY) / 2).toFixed(5)}`]);
        }
        if (props.id) rows.push(['Annotation ID', `<a class="link" href="${esc(props.id)}" target="_blank" rel="noreferrer">${short(props.id)}</a>`]);
        return `<div class="kvgrid">${rows.map(([k, v]) => `<div class="kv-key">${esc(k)}</div><div class="kv-val">${v}</div>`).join('')}</div>`;
    }
    function renderMetadataSummary(annotation, feature, extent3857) {
        if (!metaSummary) return;
        try {
            const props = annotation || null;
            const extent4326 = extent3857 ? ol.proj.transformExtent(extent3857, 'EPSG:3857', 'EPSG:4326') : null;
            metaSummary.innerHTML = buildSummaryHTML(props, feature, extent4326) || '–';
        } catch (e) {
            console.error(e);
            metaSummary.textContent = 'Could not render summary.';
        }
    }

    // --- Initialization from Google Sheet ---
    async function initializeApp() {
      // 1. PASTE YOUR GOOGLE SHEET URL HERE
      // Instructions: In Google Sheets, go to File > Share > Publish to web.
      // Select your sheet, choose "Comma-separated values (.csv)", and publish.
      // Copy the generated URL and paste it below.
      const googleSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQivs6N80xA_Pgs0J8MMMTGcH4YLzjhhyxPUoMcoQTxHjUyRXo5FMOICXDSxayDcLYisABkoqvXiIiA/pub?output=csv';

      async function loadMapDatasetFromSheet(url) {
        if (url.includes('YOUR_SHEET_ID')) {
          console.warn("Google Sheet URL is a placeholder. Please replace it in the script.");
          if (statusEl) {
            statusEl.textContent = 'Please configure the Google Sheet URL in the HTML file.';
            statusEl.className = 'small error';
          }
          return [];
        }
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const csvText = await response.text();
          const lines = csvText.trim().split(/\r?\n/);
          const header = lines.shift().split(',').map(h => h.trim().toLowerCase());
          const nameIndex = header.indexOf('name');
          const idIndex = header.indexOf('id');
          if (nameIndex === -1 || idIndex === -1) throw new Error("CSV must have 'name' and 'id' columns.");

          const maps = lines.map(line => {
            const values = line.match(/(".*?"|[^",\r\n]+)(?=\s*,|\s*$)/g) || [];
            const name = (values[nameIndex] || '').replace(/"/g, '').trim();
            const id = (values[idIndex] || '').replace(/"/g, '').trim();
            return (name && id) ? { name, id } : null;
          }).filter(Boolean);

          return maps;
        } catch (error) {
          console.error("Could not load map dataset from Google Sheet:", error);
          if (statusEl) {
            statusEl.textContent = 'Failed to load map list from Google Sheet.';
            statusEl.className = 'small error';
          }
          return [];
        }
      }

      const mapDataset = await loadMapDatasetFromSheet(googleSheetUrl);

      function populateMapSelector() {
        if (!mapSelector) return;
        mapSelector.innerHTML = '<option value="" disabled selected>Select a map from the list...</option>';
        mapDataset.forEach(map => {
          const option = document.createElement('option');
          option.value = map.id;
          option.textContent = map.name;
          mapSelector.appendChild(option);
        });
      }

      mapSelector.addEventListener('change', () => {
        const selectedId = mapSelector.value;
        if (selectedId) {
          loadAllmaps(selectedId);
          if (customMapIdInput) customMapIdInput.value = '';
        }
      });

      if (loadCustomBtn && customMapIdInput) {
        const loadFromInput = () => {
          const id = customMapIdInput.value.trim();
          if (id) {
            loadAllmaps(id);
            mapSelector.value = ''; // Deselect dropdown
          }
        };
        loadCustomBtn.addEventListener('click', loadFromInput);
        customMapIdInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') loadFromInput();
        });
      }

      populateMapSelector();

      // Auto-load logic: use URL param `id` if valid, otherwise load the first map in the list.
      const u = new URL(location.href);
      const qid = u.searchParams.get('id');
      let idToLoad = null;

      if (qid && mapDataset.some(m => m.id === qid)) {
        idToLoad = qid;
      } else if (mapDataset.length > 0) {
        idToLoad = mapDataset[0].id;
      }

      if (idToLoad) {
        mapSelector.value = idToLoad;
        loadAllmaps(idToLoad);
      } else if (mapDataset.length === 0 && !statusEl.textContent) {
        if (statusEl) statusEl.textContent = 'No maps found in the provided list.';
      }
    }

    initializeApp().catch(console.error);
  </script>
</body>
</html>
